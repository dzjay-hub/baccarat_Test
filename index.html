<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ç™¾å®¶æ¨‚ â€¢ è·¯ç›¤ç‰ˆ</title>
<style>
  :root {
    --bg: #0a1f14;
    --card: rgba(15, 40, 30, 0.7);
    --glass: rgba(255,255,255,0.06);
    --border: rgba(255,255,255,0.14);
    --player: #00aaff;
    --banker: #ff3366;
    --tie: #00c853;
    --text: #f0f0f5;
    --text-light: #a0a0b5;
    --glow-player: 0 0 16px #00aaff66;
    --glow-banker: 0 0 16px #ff336666;
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* é ‚éƒ¨å›ºå®šè³‡è¨Šæ¢ */
  #topInfo {
    position: sticky;
    top: 0;
    z-index: 100;
    background: var(--card);
    backdrop-filter: blur(12px);
    border-bottom: 1px solid var(--border);
    padding: 12px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 12px;
    font-size: 1.1rem;
  }

  #balanceDisplay {
    color: #ffd700;
    font-weight: bold;
  }

  #currentBetDisplay {
    font-weight: 500;
  }

  #app {
    display: flex;
    height: calc(100vh - 60px);
  }

  #leftPanel {
    width: 360px;
    max-width: 38%;
    padding: 16px;
    background: var(--card);
    backdrop-filter: blur(10px);
    border-right: 1px solid var(--border);
    overflow-y: auto;
  }

  #rightPanel {
    flex: 1;
    padding: 16px;
    overflow-y: auto;
  }

  /* ç»ç’ƒè³ªæ„ŸæŒ‰éˆ• */
  .glass-btn {
    background: var(--glass);
    backdrop-filter: blur(12px);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 10px 16px;
    color: white;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.25s ease;
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
  }

  .glass-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  }

  .glass-btn:active {
    transform: translateY(0);
  }

  /* å¤§å‹æŠ•æ³¨æŒ‰éˆ• */
  .bet-group {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin: 16px 0;
  }

  .bet-btn {
    height: 64px;
    font-size: 1.35rem;
    font-weight: bold;
    border-radius: 14px;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }

  .bet-btn.player {
    background: linear-gradient(145deg, #0088ff, #00aaff);
    box-shadow: var(--glow-player);
  }

  .bet-btn.banker {
    background: linear-gradient(145deg, #ff1a5c, #ff3366);
    box-shadow: var(--glow-banker);
  }

  .bet-btn.tie {
    background: linear-gradient(145deg, #00c853, #2ecc71);
  }

  /* è·¯åœ–æ¨™é¡Œ */
  .road-title {
    color: var(--text-light);
    font-size: 1.15rem;
    margin: 16px 0 8px;
    font-weight: 500;
  }

  .road-container {
    background: rgba(0,0,0,0.25);
    border-radius: 12px;
    padding: 12px;
    margin-bottom: 16px;
    border: 1px solid var(--border);
    overflow-x: auto;
  }

  /* è·¯é»æ ¼å­ - æ”¾å¤§åˆ°26px */
  .cell {
    width: 26px;
    height: 26px;
    border-radius: 50%;
    margin: 3px;
    font-size: 13px;
    line-height: 26px;
    text-align: center;
    position: relative;
  }

  .player   { background: var(--player);   box-shadow: var(--glow-player); }
  .banker   { background: var(--banker);   box-shadow: var(--glow-banker); }
  .tie      { background: #0d331a; border: 2px solid #00c853; }

  .hollow {
    background: transparent !important;
    border: 2.5px solid;
    border-radius: 6px;
  }

  .slash::after {
    content: "/";
    position: absolute;
    top: 2px;
    left: 8px;
    color: white;
    font-weight: bold;
    font-size: 16px;
  }


  /* å¡ç‰Œ */
  .card {
    width: 54px;
    height: 80px;
    background: linear-gradient(135deg, #f0f0f0, #e0e0e0);
    color: #111;
    border-radius: 8px;
    margin: 6px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 1.7rem;
    font-weight: bold;
    transform: rotate(2deg);
  }

  .card:nth-child(2) { transform: rotate(-2deg); }

  /* è¼¸å…¥æ¡†çµ±ä¸€æ¨£å¼ */
  input[type="number"] {
    background: var(--glass);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 10px;
    color: white;
    width: 100%;
  }

  /* éŸ¿æ‡‰å¼ - æ‰‹æ©Ÿ/çª„è¢å¹• */
  @media (max-width: 920px) {
    #app {
      flex-direction: column;
      height: auto;
    }
    #leftPanel {
      width: 100%;
      max-width: 100%;
      border-right: none;
      border-bottom: 1px solid var(--border);
    }
    .bet-group {
      grid-template-columns: 1fr;
    }
    .bet-btn {
      height: 70px;
      font-size: 1.4rem;
    }
  }

  /* å¼·åˆ¶ä¿®å¾©æ´¾ç”Ÿè·¯é¡è‰² - æ”¾åœ¨ CSS æœ€ä¸‹é¢ */
.cell.red {
  background-color: #ff4d4d !important;      /* é®®ç´… */
  border: 2px solid #ff4d4d !important;
  color: white !important;
  box-shadow: 0 0 8px #ff4d4d80 !important;
}

.cell.blue {
  background-color: #1e90ff !important;      /* äº®è— */
  border: 2px solid #1e90ff !important;
  color: white !important;
  box-shadow: 0 0 8px #1e90ff80 !important;
}

/* ç¢ºä¿ hollow æ™‚åªæ”¹é‚Šæ¡†ï¼Œä¸å½±éŸ¿èƒŒæ™¯ */
.cell.hollow.red {
  background: transparent !important;
  border-color: #ff4d4d !important;
}

.cell.hollow.blue {
  background: transparent !important;
  border-color: #1e90ff !important;
}

/* å•è·¯æ ¼å­ä¹Ÿå¥—ç”¨ç›¸åŒé¡è‰²è¦å‰‡ */
/* =========================
   å•è·¯æ ¼å­ï¼ˆæœ€çµ‚æ¨™æº–ç‰ˆï¼‰
   ========================= */

/* =========================
   å•è·¯æ ¼å­ï¼ˆæœ€çµ‚æ¨™æº–ç‰ˆ - å¤§çœ¼ä¹Ÿç©ºå¿ƒï¼‰
   ========================= */

.askCell {
  width: 34px;
  height: 34px;
  margin: 0 8px;
  position: relative;
  display: inline-block;
  border-radius: 50%;
  background: rgba(40,40,40,0.4);
  border: 2px solid #555;
  box-sizing: border-box;
}

/* ===== é¡è‰² ===== */
.askCell.red    { border-color: #ff4d4d; color: #ff4d4d; }
.askCell.blue   { border-color: #1e90ff; color: #1e90ff; }

/* ===== å¤§çœ¼è·¯ï¼šå¼·åˆ¶ç©ºå¿ƒåœ“ ===== */
.askCell.eye {
  background: transparent !important;
  border-width: 3px !important;
  border-style: solid !important;
}

.askCell.eye.red  { border-color: #ff4d4d !important; }
.askCell.eye.blue { border-color: #1e90ff !important; }

/* ===== å°è·¯ï¼šå¯¦å¿ƒåœ“ ===== */
.askCell.small.red { 
  background-color: #ff4d4d !important; 
  border-color: #ff4d4d !important; 
}

.askCell.small.blue { 
  background-color: #1e90ff !important; 
  border-color: #1e90ff !important; 
}
/* ===== æ›±ç”´è·¯ï¼šç©ºå¿ƒ + æ–œç·š ===== */
.askCell.cock {
  background: transparent !important;
  border-width: 3px !important;
}

.askCell.cock.red  { border-color: #ff4d4d !important; color: #ff4d4d !important; }
.askCell.cock.blue { border-color: #1e90ff !important; color: #1e90ff !important; }

.askCell.cock::after {
  content: "/";
  position: absolute;
  top: 3px;
  left: 11px;
  font-size: 18px;
  font-weight: 600;
  color: currentColor;
  z-index: 5;
  pointer-events: none;
}

/* é˜²æ­¢äº’ç›¸æ±¡æŸ“ */
.askCell.small.hollow { background: transparent !important; }
/* =========================
   æ­£å¼æ›±ç”´è·¯ï¼šç©ºå¿ƒåœ† + æ–œæ 
   ========================= */

#cockroachRoad .cell {
  background: transparent !important;   /* ğŸ”¥å»æ‰å®å¿ƒ */
  border-width: 3px;
}

#cockroachRoad .cell.red {
  border-color: #ff4d4d !important;
  color: #ff4d4d !important;
}

#cockroachRoad .cell.blue {
  border-color: #1e90ff !important;
  color: #1e90ff !important;
}

#cockroachRoad .cell.slash::after {
  content: "/";
  position: absolute;
  top: 0px;
  left: 8px;
  font-size: 16px;
  font-weight: 700;
  color: currentColor;
  pointer-events: none;
  color: currentColor !important;
}

.select-black {
  color: #000;
}

/* åªé‡å°å¤§çœ¼è·¯å®¹å™¨å…§çš„ .cell æ”¹æˆç©ºå¿ƒåœ“ */
#bigEye .cell {
  background: transparent !important;
  border: 3px solid transparent !important;  /* å…ˆè¨­é€æ˜ï¼Œé¿å…é¡è‰²è¡çª */
  border-width: 3px !important;
  border-style: solid !important;
  border-radius: 50% !important;             /* å¼·åˆ¶åœ“å½¢ */
  box-shadow: none !important;
}

/* é¡è‰²æ‡‰ç”¨åˆ°é‚Šæ¡† */
#bigEye .cell.red {
  border-color: #ff4d4d !important;
  background: transparent !important;
}

#bigEye .cell.blue {
  border-color: #1e90ff !important;
  background: transparent !important;
}
/* ç¢ºä¿ hollow é¡å‹ä¹Ÿç¶­æŒåœ“å½¢ç©ºå¿ƒ */
#bigEye .cell.hollow {
  background: transparent !important;
  border-radius: 50% !important;
}
/* =========================
   ğŸ“± å®ç›˜æ¨¡å¼ Â· æ‰‹æœº UI
   ========================= */
/* =========================
   ğŸ“± å®ç›˜æ¨¡å¼ï¼ˆå¸¦è·¯å›¾ï¼‰
   ========================= */

.live-panel{
  position: fixed;
  inset: 0;
  background: #0a1f14;
  z-index: 9999;
  display: none;
  flex-direction: column;
}

/* ===== è·¯å›¾åŒº ===== */
.live-road-area{
  padding: 10px;
  border-bottom: 1px solid #333;
  flex: 1; /* å…è®¸è·¯å›¾åŒºæ‰©å±• */
  overflow-y: auto; /* é˜²æ­¢è·¯å›¾è¿‡é•¿æº¢å‡º */
}

.live-road-area .road{
  position: relative;
  min-height: 160px;
  margin-bottom: 8px;
}

.road-sub{
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 6px;
}

/* ===== è¾“å…¥åŒº ===== */
.live-input-area{
  padding: 14px;
}

.live-btn-group{
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.live-btn{
  height: 90px;
  font-size: 32px;
  font-weight: 800;
  border-radius: 18px;
  border: none;
  color: white;
}

.live-btn.banker{
  background:#ff3366;
}
.live-btn.player{
  background:#1e90ff;
}
.live-btn.tie{
  grid-column: span 2;
  height: 70px;
  background:#2ecc71;
}

/* ===== å»ºè®®åŒº ===== */
.live-advice-area{
  padding: 12px;
}

.live-advice{
  height: 70px;
  background:#111;
  border-radius: 14px;
  font-size: 26px;
  font-weight: 700;
  color:#ffd700;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* ===== åº•éƒ¨ ===== */
.live-footer{
  margin-top:auto;
  display:flex;
  gap:10px;
  padding:12px;
}

.live-footer button{
  flex:1;
  height:48px;
  font-size:16px;
  border-radius:12px;
  border:none;
  background:#333;
  color:white;
}


/* æ–°å¢ï¼šæ‰‹æœºé€‚é…ä¼˜åŒ– - é€šç”¨ */
/* ç¡®ä¿å…¨å±é€‚é…ä¸åŒæ‰‹æœºï¼ˆå¦‚iPhoneçš„åˆ˜æµ·å±ã€å®‰å…¨åŒºåŸŸï¼‰ */
@supports (padding-top: env(safe-area-inset-top)) {
  .live-panel {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
  }
}

/* æ‰‹æœºå°å±ä¼˜åŒ–ï¼ˆå®½åº¦ < 400pxï¼Œå¦‚æ—§iPhoneï¼‰ */
@media (max-width: 400px) {
  .live-road-area {
    padding: 5px;
  }

  .live-btn {
    height: 70px;
    font-size: 24px;
  }

  .live-btn.tie {
    height: 60px;
  }

  .live-advice {
    height: 60px;
    font-size: 20px;
  }

  .live-footer button {
    height: 40px;
    font-size: 14px;
  }

  .cell {
    width: 20px;
    height: 20px;
    margin: 2px;
    font-size: 10px;
    line-height: 20px;
  }

  .askCell {
    width: 28px;
    height: 28px;
    margin: 0 4px;
  }
}

/* ç«–å±æ¨¡å¼ï¼ˆportraitï¼‰ - é»˜è®¤æ˜¯columnï¼Œä¼˜åŒ–è·¯å›¾é«˜åº¦ */
@media (orientation: portrait) {
  .live-road-area {
    flex: 2; /* åœ¨ç«–å±ä¸‹ç»™è·¯å›¾æ›´å¤šç©ºé—´ */
    min-height: 40vh;
  }

  .live-input-area {
    flex: 1;
  }

  .live-btn-group {
    grid-template-columns: repeat(2, 1fr); /* ä¿æŒåŒåˆ— */
  }

  .road-sub {
    grid-template-columns: repeat(3, 1fr); /* å­è·¯ä¿æŒä¸‰åˆ— */
  }
}

/* æ¨ªå±æ¨¡å¼ï¼ˆlandscapeï¼‰ - è°ƒæ•´ä¸ºè¡Œå¸ƒå±€ä»¥åˆ©ç”¨å®½åº¦ */
@media (orientation: landscape) {
  .live-panel {
    flex-direction: row; /* æ¨ªå±æ—¶æ”¹ä¸ºå·¦å³å¸ƒå±€ */
    align-items: stretch;
  }

  .live-road-area {
    flex: 1 1 60%; /* è·¯å›¾å å·¦ä¾§60% */
    overflow-x: auto;
    overflow-y: hidden;
    padding: 10px;
    border-right: 1px solid #333; /* æ”¹ä¸ºå³è¾¹æ¡† */
    border-bottom: none;
  }

  .live-input-area {
    flex: 1 1 40%; /* è¾“å…¥åŒºå å³ä¾§40% */
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 10px;
  }

  .live-btn-group {
    grid-template-columns: 1fr; /* æ¨ªå±ä¸‹æŒ‰é’®å•åˆ—ï¼Œå‚ç›´æ’åˆ— */
    gap: 8px;
  }

  .live-btn {
    height: 60px;
    font-size: 28px;
  }

  .live-btn.tie {
    grid-column: span 1; /* å–æ¶ˆspan */
    height: 60px;
  }

  .live-advice-area {
    padding: 10px;
  }

  .live-advice {
    height: 50px;
    font-size: 22px;
  }

  .live-footer {
    flex-direction: column; /* åº•éƒ¨æŒ‰é’®å‚ç›´ */
    gap: 8px;
    margin-top: 10px;
  }

  .live-footer button {
    height: 40px;
  }

  /* è·¯å›¾åœ¨æ¨ªå±ä¸‹è°ƒæ•´ç½‘æ ¼ */
  .road-sub {
    grid-template-columns: repeat(1, 1fr); /* å­è·¯å•åˆ—å‚ç›´ */
    gap: 10px;
  }

  .road {
    min-height: 100px; /* æ¨ªå±ä¸‹è·¯å›¾é«˜åº¦å‡å° */
  }
}

/* =========================
   ğŸ“± å®ç›˜æ¨¡å¼ Â· è·¯å›¾ç¼©æ”¾
   ========================= */

/* å®ç›˜æ¨¡å¼ä¸‹ï¼šæ•´ä½“å­—å· & é—´è·æ›´ç´§å‡‘ */
/* =========================
   ğŸ“± å®ç›˜æ¨¡å¼ Â· æé™å‹ç¼©ç‰ˆ
   ========================= */

/* ===== æ•´ä¸ªå®ç›˜é¢æ¿ç¼©ç´§ ===== */
#livePanel {
  font-size: 11px;
}

/* =========================
   â‘  å¤§è·¯ï¼šç¼©å°åˆ° 70%
   ========================= */
#liveBigRoad {
  transform: scale(0.5);
  transform-origin: top left;
  overflow: visible;
}

/* å¤§è·¯æ ¼å­è¿›ä¸€æ­¥å‹ç¼© */
#liveBigRoad .cell {
  width: 18px;
  height: 18px;
  margin: 2px;
  font-size: 9px;
  line-height: 18px;
}

/* =========================
   â‘¡ æ´¾ç”Ÿè·¯ï¼š= å¤§è·¯çš„ 1/4
   â†’ 0.7 Ã— 0.25 = 0.175
   ========================= */
#liveBigEye,
#liveSmallRoad,
#liveCockroachRoad {
  transform: scale(0.175);
  transform-origin: top left;
  overflow: visible;
}

/* æ´¾ç”Ÿè·¯å®¹å™¨é«˜åº¦å¼ºåˆ¶å‹æ‰ */
.road-sub > div {
  height: 60px;
  overflow: hidden;
}

/* æ´¾ç”Ÿè·¯æ ‡é¢˜æå°åŒ– */
.road-sub .road-title {
  font-size: 9px;
  margin-bottom: 2px;
  opacity: 0.75;
}

/* =========================
   â‘¢ æ´¾ç”Ÿè·¯æ ¼å­ï¼ˆé˜²æ­¢å˜å½¢ï¼‰
   ========================= */
#liveBigEye .cell,
#liveSmallRoad .cell,
#liveCockroachRoad .cell {
  width: 18px;
  height: 18px;
  margin: 1px;
}

/* =========================
   â‘£ ç«–å±ä¸“ç”¨ï¼šå…¨éƒ¨å¡è¿›ä¸€å±
   ========================= */
@media (orientation: portrait) {
  .live-road-area {
    flex: none;
    max-height: 45vh;   /* ğŸ”¥ è·¯å›¾åŒºæœ€å¤šå  45% å±å¹• */
    overflow: hidden;
  }
}

/* åªæ”¾å¤§å¯¦ç›¤æ¨¡å¼çš„ã€Œä¸‹ä¸€å±€å»ºè­°ã€å€åŸŸï¼Œè®“å®ƒä½”ç´„41.4%ç•«é¢é«˜åº¦ */
@media (orientation: portrait) 
   and (min-height: 2600px) {
  
  /* å»ºè­°å€åŸŸæ•´é«”æ”¾å¤§ + ä½”æ¯” */
  .live-advice-area {
    flex: 0 0 41.4%;          /* ç›´æ¥ä½”ç•«é¢é«˜åº¦ç´„41.4% */
    padding: 0;
    margin: 0;
    background: transparent;   /* è®“èƒŒæ™¯èå…¥ä¸»é¢æ¿ */
  }

  /* æ ¸å¿ƒå»ºè­°æ–‡å­—ï¼šè¶…å¤§ã€è¶…é¡¯çœ¼ */
  .live-advice {
    height: 100%;             /* å¡«æ»¿æ•´å€‹å€åŸŸ */
    font-size: 68px;          /* å­—é«”æ¥µå¤§ï¼Œé©åˆå¤§è¢å¹• */
    font-weight: 900;
    line-height: 1.15;
    letter-spacing: 3px;
    text-shadow: 0 6px 20px rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 20px;
    border-radius: 0;
    border: none;
    background: #111;
    box-shadow: inset 0 0 40px rgba(0,0,0,0.8);
    color: #ffd700;           /* é‡‘è‰²æ›´é†’ç›® */
  }

  /* ç•¶æœ‰æ˜ç¢ºå»ºè­°æ™‚åŠ å‹•ç•«å¼·èª¿ */
  .live-advice:not(:contains("ç­‰å¾…")):not(:contains("è‡ªè¡Œ")) {
    background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
    animation: glow 1.8s infinite alternate;
  }

  @keyframes glow {
    from { box-shadow: inset 0 0 20px #ffd70080; }
    to   { box-shadow: inset 0 0 60px #ffd700cc; }
  }
}


</style>
</head>
<body>



<div id="topInfo">
  
<div style="margin:20px 0; display:flex; gap:12px;">
      ä½™é¢ï¼š<input id="balanceInput" type="number" value="1000">
      <button class="glass-btn" onclick="setBalance()">ç¡®è®¤</button>
      <h2>ä½™é¢ï¼š<span id="balance">1000</span></h2></div>
    </div>

  
  <div id="currentBetDisplay">ç•¶å‰ä¸‹æ³¨ï¼š<span id="currentBet">ç„¡</span></div>
  <div id="resultText" style="color:#ffd700; font-weight:bold;"></div>
</div>

<div id="app">

  <!-- å·¦å´æ“ä½œå€ -->
  <div id="leftPanel">
<button class="glass-btn" onclick="enterLiveMode()">
  ğŸ“± å®ç›˜æ¨¡å¼
</button>

    <div class="bet-group">
      <button class="bet-btn glass-btn player" onclick="bet('player')">æŠ¼é–’</button>
      <button class="bet-btn glass-btn banker" onclick="bet('banker')">æŠ¼èŠ</button>
    </div>

    <button class="bet-btn glass-btn tie" style="width:100%; margin:16px 0 8px;" onclick="bet('tie')">æŠ¼å’Œ</button>
    <button class="glass-btn" style="width:100%;" onclick="betSuper6()">æŠ¼è¶…ç´š6</button>
    <p style="margin:8px 0; color:#a0a0b5;">è¶…ç´š6ä¸‹æ³¨ï¼š<span id="super6BetText">0</span></p>

    <div style="margin:20px 0; display:flex; gap:12px;">
      <input type="number" id="betAmountInput" value="100">
      <button class="glass-btn" onclick="setBetAmount()">ç¢ºèªé‡‘é¡</button>
    </div>

    <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(90px,1fr)); gap:10px; margin:16px 0;">
      <button class="glass-btn" onclick="quickBet(300)">300</button>
      <button class="glass-btn" onclick="quickBet(500)">500</button>
      <button class="glass-btn" onclick="quickBet(1000)">1000</button>
      <button class="glass-btn" onclick="quickBet(3000)">3000</button>
      <button class="glass-btn" onclick="allIn()">ALL IN</button>
    </div>

    <div style="margin:20px 0; display:flex; gap:12px;">
      <button class="glass-btn" style="flex:1;" onclick="startRound()">ç™¼ç‰Œ</button>
      <button class="glass-btn" style="flex:1;" onclick="dealNoBet()">ä¸ä¸‹æ³¨ç™¼ç‰Œ</button>
    </div>

    <div style="margin-top:24px; padding-top:16px; border-top:1px solid var(--border);">
      <h3 style="color:var(--text-light); margin-bottom:12px;">ä¸‹æ³¨çµ±è¨ˆ</h3>
      <div style="line-height:1.6;">
        å·²ä¸‹æ³¨ï¼š<span id="betCount">0</span>ã€€å±€<br>
        è´å¾—ã€€ã€€ï¼š<span id="winCount">0</span>ã€€å±€<br>
        å‹ç‡ã€€ã€€ï¼š<span id="winRate">0%</span>
      </div>
    </div>

  

    <h3 style="margin-top:20px;">å›æµ‹è®¾ç½®</h3>

    <select class="glass-btn select-black" id="btWhen" >
      
      <option value="smallFollow" >å°è·¯é¡º</option>
      <option value="bigEyeFollow">å¤§çœ¼é¡º</option>
      <option value="reverse">åæ‰“</option>
      <option value="bankerLowReverse">åº„â‰¤6èµ¢ â†’ åæ‰“é—²</option>
      <option value="zeroPointFollowPlayer">
    å‡ºç°0ç‚¹ï¼ˆéå’Œï¼‰â†’ ä¸‹é—²
  </option>
    </select>

    <select class="glass-btn select-black" id="btSizer">
      <option value="martingale">100-300-600-1200</option>
      <option value="flat">å›ºå®š100</option>
    </select>

    <input id="btRounds" type="number" value="100" />

    <button class="glass-btn" onclick="startBacktest()">å¼€å§‹å›æµ‹</button>
    <button class="glass-btn" style="width:100%; margin-top:24px; padding:14px;" onclick="runSuper6FollowSimulation(100000)">
      è¶…ç´š6 â†’ è·ŸæŠ¼é–’ å›æ¸¬ 10è¬å±€
    </button>
    <button class="glass-btn" style="width:100%; margin-top:8px;"
        onclick="startPatternScoreBacktest()">
  å››è·¯è§„å¾‹ç§¯åˆ†å›æµ‹
</button>
  </div>

  <!-- å³å´è·¯åœ–å€ -->
<div id="rightPanel">

  <div class="road-title" id="shoeIndicator">ç•¶å‰ï¼šæ–°ä¸€é´</div>

  
  <!-- ä¸‹ä¸€å±€åƒè€ƒ + å¯¦éš›ç‰Œ æ”¾åœ¨åŒä¸€è¡Œ -->
<div style="margin: 16px 0 24px;">
  <div class="road-title" style="margin-bottom: 12px;">ä¸‹ä¸€å±€åƒè€ƒï¼ˆå•è·¯ï¼‰ã€€ã€€å¯¦éš›ç™¼ç‰Œçµæœ</div>
  
  <div style="display: flex; align-items: flex-start; gap: 32px; flex-wrap: wrap;">
    
    <!-- å·¦é‚Šï¼šå•è·¯ -->
    <div style="min-width: 220px;">
      <div style="margin-bottom: 12px;">
        èŠã€€ï¼š<span id="askBankerEye"   class="askCell"></span>
<span id="askBankerSmall" class="askCell"></span>
<span id="askBankerCock"  class="askCell"></span>
      </div>
      <div>
        é–’ã€€ï¼š<span id="askPlayerEye"   class="askCell"></span>
<span id="askPlayerSmall" class="askCell"></span>
<span id="askPlayerCock"  class="askCell"></span>
      </div>
    </div>

    <!-- å³é‚Šï¼šå¯¦éš›ç‰Œï¼ˆä¿æŒä¸è®Šï¼‰ -->
    <div style="flex: 1; min-width: 320px;">
      <div style="display: flex; justify-content: flex-start; gap: 40px; flex-wrap: wrap;">
        <!-- é–’å®¶ç‰Œ -->
        <div>
          <h4 style="margin: 0 0 8px 0; color: var(--player); text-align: center; font-weight: 500;">é–’</h4>
          <div id="playerCards" style="display: flex; gap: 10px; flex-wrap: nowrap;"></div>
        </div>
        <!-- èŠå®¶ç‰Œ -->
        <div>
          <h4 style="margin: 0 0 8px 0; color: var(--banker); text-align: center; font-weight: 500;">èŠ</h4>
          <div id="bankerCards" style="display: flex; gap: 10px; flex-wrap: nowrap;"></div>
        </div>
      </div>
    </div>

  </div>
</div>

  <!-- å¾Œé¢çš„å¤§è·¯é–‹å§‹ç…§èˆŠ -->
  <div class="road-container">
    <div class="road-title">å¤§è·¯</div>
    <div id="bigRoad" class="road"></div>
  </div>

  <div class="road-container">
    <div class="road-title">å¤§çœ¼</div>
    <div id="bigEye" class="road"></div>
  </div>

  <div class="road-container">
    <div class="road-title">å°è·¯</div>
    <div id="smallRoad" class="road"></div>
  </div>

  <div class="road-container">
    <div class="road-title">æ›±ç”´è·¯</div>
    <div id="cockroachRoad" class="road"></div>
  </div>

  <div class="road-container">
    <div class="road-title">ç ç›¤è·¯</div>
    <div id="beadRoad" style="display:flex; flex-wrap:wrap;"></div>
  </div>

</div>
<!-- =========================
     ğŸ“± å®ç›˜æ¨¡å¼ï¼ˆå¸¦è·¯å›¾ï¼‰
     ========================= -->
<div id="livePanel" class="live-panel">

  <!-- é¡¶éƒ¨ï¼šè·¯å›¾ -->
  <div class="live-road-area">
    <!-- å…ˆç¢ºèª livePanel è£¡çš„å•è·¯é¡¯ç¤ºå€ HTML æ˜¯ä¹¾æ·¨çš„ -->
<div id="liveAskPanel">
  <div class="ask-col">ä¸‹ä¸€å±€
    <div class="title">èŠ</div>
    <div>å¤§çœ¼ï¼š<span id="live-ask-b-eye"   class="askCell"></span></div>
    <div>å°è·¯ï¼š<span id="live-ask-b-small" class="askCell"></span></div>
    <div>æ›±ç”´ï¼š<span id="live-ask-b-cock"  class="askCell"></span></div>
  </div>

  <div class="ask-col">
    <div class="title">é–’</div>
    <div>å¤§çœ¼ï¼š<span id="live-ask-p-eye"   class="askCell"></span></div>
    <div>å°è·¯ï¼š<span id="live-ask-p-small" class="askCell"></span></div>
    <div>æ›±ç”´ï¼š<span id="live-ask-p-cock"  class="askCell"></span></div>
  </div>
</div>

    <div class="road-title">å¤§è·¯</div>
    <div id="liveBigRoad" class="road"></div>

    <div class="road-sub">
      <div>
        <div class="road-title">å¤§çœ¼</div>
        <div id="liveBigEye" class="road"></div>
      </div>
      <div>
        <div class="road-title">å°è·¯</div>
        <div id="liveSmallRoad" class="road"></div>
      </div>
      <div>
        <div class="road-title">æ›±ç”´</div>
        <div id="liveCockroachRoad" class="road"></div>
      </div>
    </div>

  </div>
<div id="livePatternPanel">
  <div class="row">å¤§è·¯ï¼š<span id="p-big">0</span></div>
  <div class="row">å¤§çœ¼ï¼š<span id="p-eye">0</span></div>
  <div class="row">å°è·¯ï¼š<span id="p-small">0</span></div>
  <div class="row">æ›±ç”´ï¼š<span id="p-cockroach">0</span></div>
</div>

  <!-- ä¸­éƒ¨ï¼šè¾“å…¥ -->
  <div class="live-input-area">

    <div class="live-label">ä¸Šä¸€å±€ç»“æœ</div>

    <div class="live-btn-group">
      <button class="live-btn banker" onclick="inputLive('banker')">åº„</button>
      <button class="live-btn player" onclick="inputLive('player')">é—²</button>
      <button class="live-btn tie" onclick="inputLive('tie')">å’Œ</button>
      <button onclick="restoreLiveSnapshot()">â†© å›é€€ä¸€å±€</button>
    </div>

  </div>

  <!-- å»ºè®® -->
  <div class="live-advice-area">
    <div class="live-label">ä¸‹ä¸€å±€å»ºè®®</div>
    <div id="liveAdvice" class="live-advice">ç­‰å¾…è¾“å…¥â€¦</div>
  </div>

  <!-- åº•éƒ¨æ§åˆ¶ -->
  <div class="live-footer">
    <button onclick="exitLiveMode()">â¬… è¿”å›ä¸»é¡µ</button>
    <button onclick="resetLiveMode()">ğŸ”„ æ¸…ç©ºè·¯ç›˜</button>
  </div>

</div>

<!-- ä½ çš„åŸå§‹ JavaScript å®Œæ•´ä¿ç•™ï¼Œä¸åšä»»ä½•åˆªæ¸› -->
<script>
// ===== å®ç›˜ Â· å›é€€å†å² =====
let liveHistory = [];


const liveAskCells = {
  bEye:   document.getElementById("live-ask-b-eye"),
  bSmall: document.getElementById("live-ask-b-small"),
  bCock:  document.getElementById("live-ask-b-cock"),
  pEye:   document.getElementById("live-ask-p-eye"),
  pSmall: document.getElementById("live-ask-p-small"),
  pCock:  document.getElementById("live-ask-p-cock")
};

  
// ä»¥ä¸‹å…¨éƒ¨ç‚ºä½ åŸæœ‰çš„ç¨‹å¼ç¢¼ï¼Œä¸€å­—æœªæ”¹
let super6Bet = 0;   // è¶…çº§6ä¸‹æ³¨é‡‘é¢

let betCount = 0;   // å·²ä¸‹æ³¨ç›˜æ•°
let winCount = 0;   // èµ¢çš„ç›˜æ•°

  /* ===== å¤§è·¯æ ¸å¿ƒçŠ¶æ€ï¼ˆä½ ç°åœ¨ç¼ºçš„ï¼‰===== */

const MAX_ROW = 6;     // å¤§è·¯å›ºå®š 6 è¡Œ

let bigMap = {};       // col -> row -> { res, tie }
let bigCol = 0;
let bigRow = 0;
let lastResult = null;



  // ===== é—®è·¯ DOM ç»‘å®šï¼ˆä½ ç°åœ¨ç¼ºçš„å°±æ˜¯è¿™ä¸ªï¼‰=====
const askBankerEye   = document.getElementById("askBankerEye");
const askBankerSmall = document.getElementById("askBankerSmall");
const askBankerCock  = document.getElementById("askBankerCock");

const askPlayerEye   = document.getElementById("askPlayerEye");
const askPlayerSmall = document.getElementById("askPlayerSmall");
const askPlayerCock  = document.getElementById("askPlayerCock");

const super6BetText = document.getElementById("super6BetText");

let autoBetState = {
  running: false,

  totalBet: 0,
  win: 0,
  lose: 0,
  tie: 0,

  curWinStreak: 0,
  curLoseStreak: 0,
  maxWinStreak: 0,
  maxLoseStreak: 0,

  lastBet: null   // "banker" | "player" | null
};


let bigEyeRoad = createRoad();
let smallRoadR = createRoad();
let cockroachRoadR = createRoad();

const betCountEl = document.getElementById("betCount");
const winCountEl = document.getElementById("winCount");
const winRateEl  = document.getElementById("winRate");



function setAskSmall(el, color) {
  // å…ˆæ¸…å¹²å‡€
  el.className = "askCell small";

  // å†åŠ é¢œè‰²
  el.classList.add(color); // "red" æˆ– "blue"
}

function dealAndResolve(isBetting){

  let p = [drawCard(), drawCard()];
  let b = [drawCard(), drawCard()];

  let pp = point(p);
  let bp = point(b);

  let pThird = null;

  /* =========================
     âœ… Step 1ï¼šä¾‹ç‰Œåˆ¤æ–­ï¼ˆ8 / 9ï¼‰
     ========================= */
  if(pp < 8 && bp < 8){

    /* =========================
       Step 2ï¼šé—²å®¶è¡¥ç‰Œ
       ========================= */
    if(pp <= 5){
      pThird = drawCard();
      p.push(pThird);
    }

    /* =========================
       Step 3ï¼šåº„å®¶è¡¥ç‰Œ
       ========================= */
    if(pThird === null){
      // é—²å®¶æœªè¡¥ç‰Œ
      if(bp <= 5){
        b.push(drawCard());
      }
    }else{
      // é—²å®¶è¡¥äº†ç¬¬ä¸‰å¼ ï¼ˆæŒ‰ä½ ç»™çš„è¡¨ï¼‰
      if(
        bp <= 2 ||
        (bp === 3 && pThird !== 8) ||
        (bp === 4 && pThird >= 2 && pThird <= 7) ||
        (bp === 5 && pThird >= 4 && pThird <= 7) ||
        (bp === 6 && (pThird === 6 || pThird === 7))
      ){
        b.push(drawCard());
      }
    }
  }

  /* =========================
     æœ€ç»ˆç‚¹æ•° & æ˜¾ç¤º
     ========================= */
  showCards("playerCards", p);
  showCards("bankerCards", b);

  pp = point(p);
  bp = point(b);
  lastBankerPoint = bp;
  lastPlayerPoint = pp;  
  let res =
    pp > bp ? "player" :
    bp > pp ? "banker" :
    "tie";

  if(isBetting){
  settle(res);
}

drawBead(res);
drawBigRoad(res);
nextRound();

}
function nextRound(){
  super6Bet = 0;
  autoBetState.lastBet = null;
}


function betSuper6(){
  if(betAmt > balance){
    alert("ä½™é¢ä¸è¶³");
    return;
  }
  super6Bet = betAmt;
  super6BetText.innerText = super6Bet;
}

function updateBetStats(){
  betCountEl.innerText = betCount;
  winCountEl.innerText = winCount;

  let rate = betCount === 0
    ? 0
    : ((winCount / betCount) * 100).toFixed(2);

  winRateEl.innerText = rate + "%";
}

function createRoad(){
  return {
    map: {},
    col: 0,
    row: 0,
    last: null
  };
}

function roadStep(road, color){
  // ç¬¬ä¸€æ‰‹
  if(road.last === null){
    road.col = 0;
    road.row = 0;
  }
  // åŒè‰² â†’ å°è¯•ä¸‹è½
  else if(color === road.last){
    if(
      road.row + 1 < MAX_ROW &&
      !road.map[road.col]?.[road.row + 1]
    ){
      road.row++;
    }else{
      // é¡¶ä½ â†’ å³ç§»
      road.col++;
    }
  }
  // ä¸åŒè‰² â†’ æ–°åˆ—
  else{
    road.col++;
    road.row = 0;
  }

  // å†™å…¥
  road.map[road.col] ??= {};
  road.map[road.col][road.row] = color;

  road.last = color;
}

/* ====== Shoeï¼ˆ8 å‰¯ç‰Œ + åœç‰Œå¡ï¼‰ ====== */

let shoe = [];
let cutPosition = 0;   // åˆ‡ç‰Œå¡ä½ç½®ï¼ˆå‰©ä½™å¤šå°‘å¼ æ—¶è§¦å‘ï¼‰
let dealtCount = 0;    // å·²å‘å¼ æ•°

function createShoe(){
  shoe = [];
  dealtCount = 0;

  // 8 å‰¯å®Œæ•´ç‰Œï¼ˆç‚¹æ•°æ¨¡å‹ï¼‰
  const oneDeck = [
    1,2,3,4,5,6,7,8,9,
    0,0,0,0,  // 10 J Q K
    1,2,3,4,5,6,7,8,9,
    0,0,0,0,
    1,2,3,4,5,6,7,8,9,
    0,0,0,0,
    1,2,3,4,5,6,7,8,9,
    0,0,0,0,  
     // å…± 52
  ];

  for(let i = 0; i < 8; i++){
    shoe.push(...oneDeck);
  }

  // æ´—ç‰Œ
  shoe.sort(() => Math.random() - 0.5);

  // ğŸ¯ åˆ‡ç‰Œå¡ï¼š65% ~ 80% ä¹‹é—´
  const min = Math.floor(shoe.length * 0.85); // 
  const max = Math.floor(shoe.length * 0.95); // 

  cutPosition = Math.floor(
    min + Math.random() * (max - min)
  );

  console.log(
    `æ–°ä¸€é´ï¼šæ€»ç‰Œ ${shoe.length}ï¼Œåˆ‡ç‰Œå¡åœ¨ç¬¬ ${cutPosition} å¼ `
  );
}

/* æŠ½ä¸€å¼ ç‰Œï¼Œå¹¶åˆ¤æ–­æ˜¯å¦è§¦å‘åœç‰Œ */
function drawFromShoe(){
  let card = shoe.pop();
  return card;
}

function getShoeProgress(){
  return `${dealtCount} / ${cutPosition}`;
}

  /* ====== ä¸‹æ³¨é‡‘é¢ ====== */
let betAmt = 100;

function setBetAmount(){
  let v = Number(betAmountInput.value);
  if(v <= 0){
    alert("ä¸‹æ³¨é‡‘é¢å¿…é¡»å¤§äº 0");
    return;
  }
  if(v > balance){
    alert("ä¸‹æ³¨é‡‘é¢ä¸èƒ½å¤§äºä½™é¢");
    return;
  }
  betAmt = v;
  updateBetText();
}

function quickBet(v){
  if(v > balance){
    alert("ä½™é¢ä¸è¶³");
    return;
  }
  betAmt = v;
  betAmountInput.value = v;
  updateBetText();
}

function allIn(){
  if(balance <= 0){
    alert("æ²¡æœ‰ä½™é¢");
    return;
  }
  betAmt = balance;
  betAmountInput.value = balance;
  updateBetText();
}

function updateBetText(){
  betAmountText.innerText = betAmt;
}

function getDerivedColor(offset, col, row){
  if(col < offset + 1) return null;

  let curHas = hasCell(col, row - 1);
  let cmpHas = hasCell(col - offset, row - 1);

  return (curHas === cmpHas) ? "red" : "blue";
}

/* ====== åˆ¤æ–­å¤§è·¯æŸæ ¼æ˜¯å¦å­˜åœ¨ ====== */
function hasCell(c, r){
  return bigMap[c] && bigMap[c][r];
}

function renderRoad(road, container, slash = false, hollow = false) {
  container.innerHTML = "";
  
  const cellSize = 26;     // æ ¼å­æœ¬é«”å¤§å°
  const spacing = 3;       // é–“è· â†’ ç¸½é–“è· 29px
  const step = cellSize + spacing;  // 29px

  Object.keys(road.map).forEach(c => {
    const col = Number(c);
    Object.keys(road.map[c]).forEach(r => {
      const row = Number(r);
      let color = road.map[c][r];  // "red" æˆ– "blue"

      let d = document.createElement("div");
      d.className = `cell ${color}`
        + (slash ? " slash" : "")
        + (hollow ? " hollow" : "");

      d.style.position = "absolute";
      d.style.left = (col * step) + "px";
      d.style.top  = (row * step) + "px";

      container.appendChild(d);
    });
  });

  container.style.position = "relative";
  container.style.height = (MAX_ROW * step + 10) + "px";  // å¤šç•™ä¸€é»ç©ºé–“
  container.style.minHeight = "180px";
  container.style.overflow = "visible";  // é¿å…æ ¼å­è¢«åˆ‡æ‰
}


let lastBankerPoint = null;
let lastPlayerPoint = null;   // â† æ–°å¢ï¼šè®°å½•ä¸Šä¸€æŠŠé—²ç‚¹æ•°

/* ====== åŸºç¡€çŠ¶æ€ ====== */
let balance = 1000;
let betType = null;


/* ====== è·¯ç›˜çŠ¶æ€ ====== */
let lastBig = null;
let bigRoadData = [];
let beadIndex = 0;

/* ====== ç‰Œå † ====== */
let deck = [];

/* ====== UI ====== */
function setBalance(){
  balance = Number(balanceInput.value);
  balanceSpan();
}
function balanceSpan(){
  balanceSpanEl.innerText = balance;
}
const balanceSpanEl = document.getElementById("balance");

/* ====== ä¸‹æ³¨ ====== */
function bet(t){
  betType = t;
  currentBet.innerText = t;
}

/* ====== ç‰Œé€»è¾‘ ====== */
function createDeck(){
  deck = [];
  let base=[1,2,3,4,5,6,7,8,9,0,0,0,0];
  for(let i=0;i<8;i++) base.forEach(c=>deck.push(c));
  deck.sort(()=>Math.random()-0.5);
}

function point(a){ return a.reduce((x,y)=>x+y,0)%10; }

function showCards(id,cards){
  let el=document.getElementById(id);
  el.innerHTML="";
  cards.forEach(v=>{
    let d=document.createElement("div");
    d.className="card";
    d.innerText=v;
    el.appendChild(d);
  });
}

function startRound(){
  if(!betType){
    alert("è¯·å…ˆä¸‹æ³¨");
    return;
  }
  dealAndResolve(true);   // âœ… ä¸‹æ³¨æ¨¡å¼
}

function dealNoBet(){
  dealAndResolve(false);  // âŒ ä¸ç»“ç®—ã€ä¸ç»Ÿè®¡
}

/* ====== ç»“ç®— ====== */
function settle(res){
  // ===== æœ¬å±€ä¸€å®šæ˜¯ä¸‹æ³¨å±€ =====
  betCount++;

  let winThisRound = false;   // æ˜¯å¦èµ¢ä¸»æ³¨ æˆ– è¶…çº§6

  /* =====================
     ä¸€ã€ä¸»æ³¨ç»“ç®—
     ===================== */
  if(res === "tie"){
    if(betType === "tie"){
      // æŠ¼å’Œï¼š1èµ”8
      balance += betAmt * 8;
      resultText.innerText = "å’Œå±€ï¼ŒæŠ¼å’Œèµ¢ Ã—8";
      winThisRound = true;
    }else{
      // æŠ¼åº„ / æŠ¼é—²ï¼šé€€å›æœ¬é‡‘ï¼ˆä¸è¾“ä¸èµ¢ï¼‰
      resultText.innerText = "å’Œå±€ï¼Œé€€å›æœ¬é‡‘";
    }
  }else{
    if(betType === res){
      balance += betAmt;
      resultText.innerText = "èµ¢ï¼š" + res;
      winThisRound = true;
    }else{
      balance -= betAmt;
      resultText.innerText = "è¾“ï¼š" + res;
    }
  }

  /* =====================
     äºŒã€è¶…çº§6ç»“ç®—ï¼ˆç‹¬ç«‹æ—æ³¨ï¼‰
     ===================== */
  if(super6Bet > 0){
    if(res === "banker" && lastBankerPoint === 6){
      // è¶…çº§6å‘½ä¸­ï¼š1èµ”11
      balance += super6Bet * 11;
      resultText.innerText += " | è¶…çº§6 èµ¢ Ã—11";
      winThisRound = true;   // ç®—èµ¢ä¸€å±€
    }else{
      balance -= super6Bet;
    }

    // æ¸…ç©ºè¶…çº§6ä¸‹æ³¨
    super6Bet = 0;
    super6BetText.innerText = "0";
  }

  /* =====================
     ä¸‰ã€ç»Ÿè®¡ & æ”¶å°¾
     ===================== */
  if(winThisRound){
    winCount++;
  }

  betType = null;
  currentBet.innerText = "æ— ";

  balanceSpan();        // åˆ·æ–°ä½™é¢
  updateBetStats();     // åˆ·æ–° èƒœç‡ / èµ¢ç›˜ / æ€»ç›˜
}

function drawBigRoad(res) {
  // ===== å’Œå±€ï¼šåªå åŠ ï¼Œä¸æ¨è¿› =====
  if (res === "tie") {
    if (bigMap[bigCol]?.[bigRow]) {
      bigMap[bigCol][bigRow].tie++;
    }
    renderBigRoad();
    renderAskRoad();
    return;
  }

  // ===== ç¬¬ä¸€æ‰‹ =====
  if (lastResult === null) {
    bigCol = 0;
    bigRow = 0;
  }

  // ===== åŒè‰²ï¼ˆè¿åº„ / è¿é—²ï¼‰=====
  else if (res === lastResult) {
    // æƒ…å†µ 1ï¼šè¿˜æ²¡åˆ°ç¬¬ 6 è¡Œï¼Œå‘ä¸‹
    if (bigRow < MAX_ROW - 1) {
      bigRow++;
    }
    // æƒ…å†µ 2ï¼šå·²ç»åˆ°ç¬¬ 6 è¡Œï¼Œå‘å³æ¨ªç€èµ°
    else {
      bigCol++;
      // â— row ä¸å˜ï¼Œä»ç„¶æ˜¯ç¬¬ 6 è¡Œ
    }
  }

  // ===== å˜è‰²ï¼šæ–°åˆ—ï¼Œæ–°èµ·ç‚¹ =====
  else {
    bigCol++;
    bigRow = 0;
  }

  // ===== å†™å…¥æ•°æ® =====
  bigMap[bigCol] ??= {};
  bigMap[bigCol][bigRow] = {
    res,
    tie: 0,
    point: lastBankerPoint
  };

  // ===== æ´¾ç”Ÿè·¯è®¡ç®— =====
  const eye   = calcBigEyeColor(bigCol, bigRow);
  const small = calcSmallRoadColor(bigCol, bigRow);
  const cock  = calcCockroachColor(bigCol, bigRow);

  if (eye)   roadStep(bigEyeRoad, eye);
  if (small) roadStep(smallRoadR, small);
  if (cock)  roadStep(cockroachRoadR, cock);

  lastResult = res;

  renderBigRoad();
  renderDerivedRoads();
  renderAskRoad();
}

/* æ¸²æŸ“å¤§è·¯ */
function renderBigRoad(){
  bigRoad.innerHTML = "";
  bigRoad.style.position = "relative";
  bigRoad.style.height = (MAX_ROW * 24) + "px";

  Object.keys(bigMap).forEach(c=>{
    Object.keys(bigMap[c]).forEach(r=>{
      const cell = bigMap[c][r];

      const d = document.createElement("div");
      d.className = "cell " + cell.res;
      d.style.position = "absolute";
      d.style.left = (c * 24) + "px";
      d.style.top  = (r * 24) + "px";

      if(cell.res === "banker" && cell.point === 6){
  d.innerHTML = "<span class='super6'>6</span>";
}

if(cell.tie > 0){
  d.innerHTML += "<div class='tieMark'>+" + cell.tie + "</div>";
}


      bigRoad.appendChild(d);
    });
  });
}

function dealOnceSim(deck){
  let p=[deck.pop(),deck.pop()];
  let b=[deck.pop(),deck.pop()];

  let pp=point(p), bp=point(b);
  let pThird=null;

  if(pp<=5){ pThird=deck.pop(); p.push(pThird); }

  if(pThird===null){
    if(bp<=5) b.push(deck.pop());
  }else{
    if(
      bp<=2 ||
      (bp===3 && pThird!==8) ||
      (bp===4 && pThird>=2 && pThird<=7) ||
      (bp===5 && pThird>=4 && pThird<=7) ||
      (bp===6 && (pThird===6 || pThird===7))
    ) b.push(deck.pop());
  }

  pp=point(p); bp=point(b);
  return pp>bp?"player":bp>pp?"banker":"tie";
}

function createSimState(){
  return {
    bigMap:{},
    bigCol:0,
    bigRow:0,
    last:null,
    bigEye:[],
    small:[],
    cockroach:[]
  };
}

function simDrawBig(state,res){
  if(res==="tie"){
    if(state.bigMap[state.bigCol]?.[state.bigRow]){
      state.bigMap[state.bigCol][state.bigRow].tie++;
    }
    return;
  }

  if(state.last===null){
    state.bigCol=0; state.bigRow=0;
  }else if(res===state.last){
    if(
      state.bigRow+1<6 &&
      !state.bigMap[state.bigCol]?.[state.bigRow+1]
    ){
      state.bigRow++;
    }else{
      state.bigCol++;
    }
  }else{
    state.bigCol++;
    state.bigRow=0;
  }

  state.bigMap[state.bigCol] ??= {};
  state.bigMap[state.bigCol][state.bigRow]={res,tie:0};

  simDerived(state);
  state.last=res;
}

function simHas(state,c,r){
  return !!state.bigMap[c]?.[r];
}

function simDerived(state){
  let c=state.bigCol, r=state.bigRow;
  [
    [state.bigEye,1],
    [state.small,2],
    [state.cockroach,3]
  ].forEach(([arr,off])=>{
    if(c>=off+1){
      let cur=simHas(state,c,r-1);
      let cmp=simHas(state,c-off,r-1);
      arr.push(cur===cmp?"red":"blue");
    }
  });
}

function runSimulation(rounds){
  let stat={
    banker:0, player:0, tie:0,
    maxBanker:0, maxPlayer:0
  };

  let state=createSimState();
  let deck=[];

  let curB=0, curP=0;

  for(let i=0;i<rounds;i++){
    if(deck.length<6){
      deck=[];
      let base=[1,2,3,4,5,6,7,8,9,0,0,0,0];
      for(let d=0;d<8;d++) base.forEach(c=>deck.push(c));
      deck.sort(()=>Math.random()-0.5);
    }

    let res=dealOnceSim(deck);

    stat[res]++;

    if(res==="banker"){
      curB++; curP=0;
      stat.maxBanker=Math.max(stat.maxBanker,curB);
    }else if(res==="player"){
      curP++; curB=0;
      stat.maxPlayer=Math.max(stat.maxPlayer,curP);
    }

    simDrawBig(state,res);
  }

  let out=`
æ€»å±€æ•°: ${rounds}

åº„: ${(stat.banker/rounds*100).toFixed(2)}%
é—²: ${(stat.player/rounds*100).toFixed(2)}%
å’Œ: ${(stat.tie/rounds*100).toFixed(2)}%

æœ€å¤§è¿åº„: ${stat.maxBanker}
æœ€å¤§è¿é—²: ${stat.maxPlayer}

å¤§çœ¼è·¯ çº¢/è“: ${countRB(state.bigEye)}
å°è·¯   çº¢/è“: ${countRB(state.small)}
æ›±ç”´è·¯ çº¢/è“: ${countRB(state.cockroach)}
`;
  simResult.textContent=out;
}

function countRB(arr){
  let r=arr.filter(x=>x==="red").length;
  let b=arr.filter(x=>x==="blue").length;
  return `${r}/${b} (${(r/(r+b)*100).toFixed(2)}% red)`;
}
function startSimulation(){
  let n = Number(simCountInput.value);

  if(!Number.isInteger(n) || n <= 0){
    alert("è¯·è¾“å…¥å¤§äº 0 çš„æ•´æ•°");
    return;
  }

  if(n > 5000){
    alert("æœ€å¤šåªèƒ½æ¨¡æ‹Ÿ 5000 å±€");
    return;
  }

  simResult.textContent = "æ¨¡æ‹Ÿä¸­ï¼Œè¯·ç¨å€™...\n";
  
  // ç»™æµè§ˆå™¨ä¸€ä¸ªåˆ·æ–°æœºä¼šï¼ˆé˜²å‡æ­»ï¼‰
  setTimeout(()=>{
    runSimulation(n);
  }, 50);
}

function dealOnceSimWithDeck(){
  // ===== ç¡®ä¿æ¨¡æ‹Ÿç”¨ deck æœ‰è¶³å¤Ÿç‰Œ =====
  if(deck.length < 6){
    deck = [];
    let base = [1,2,3,4,5,6,7,8,9,0,0,0,0];
    for(let d = 0; d < 8; d++){
      base.forEach(c => deck.push(c));
    }
    deck.sort(() => Math.random() - 0.5);
  }

  // ===== å‘å‰ä¸¤å¼  =====
  let p = [deck.pop(), deck.pop()];
  let b = [deck.pop(), deck.pop()];

  let pp = point(p);
  let bp = point(b);
  let pThird = null;

  /* ===== ä¾‹ç‰Œï¼ˆ8 / 9ï¼‰ ===== */
  if(pp < 8 && bp < 8){

    /* ===== é—²å®¶è¡¥ç‰Œ ===== */
    if(pp <= 5){
      pThird = deck.pop();
      p.push(pThird);
    }

    /* ===== åº„å®¶è¡¥ç‰Œ ===== */
    if(pThird === null){
      if(bp <= 5){
        b.push(deck.pop());
      }
    }else{
      if(
        bp <= 2 ||
        (bp === 3 && pThird !== 8) ||
        (bp === 4 && pThird >= 2 && pThird <= 7) ||
        (bp === 5 && pThird >= 4 && pThird <= 7) ||
        (bp === 6 && (pThird === 6 || pThird === 7))
      ){
        b.push(deck.pop());
      }
    }
  }

  // ===== è®¡ç®—ç»“æœ =====
  pp = point(p);
  bp = point(b);

  return pp > bp ? "player" : bp > pp ? "banker" : "tie";
}


let simRunning = false;
let simRemain = 0;

function startAutoSimulation(){
  let n = Number(simCountInput.value);
  if(n<=0 || n>5000){
    alert("æ¨¡æ‹Ÿå±€æ•° 1 ~ 5000");
    return;
  }

  simRemain = n;
  simRunning = true;

  createShoe();   // æ–°ä¸€è½® Shoe
  autoStep();
}

function dealOnceSimWithShoe(){
  let p = [drawCard(), drawCard()];
  let b = [drawCard(), drawCard()];

  let pp = point(p);
  let bp = point(b);
  let pThird = null;

  if(pp < 8 && bp < 8){
    if(pp <= 5){
      pThird = drawCard();
      p.push(pThird);
    }

    if(pThird === null){
      if(bp <= 5){
        b.push(drawCard());
      }
    }else{
      if(
        bp <= 2 ||
        (bp === 3 && pThird !== 8) ||
        (bp === 4 && pThird >= 2 && pThird <= 7) ||
        (bp === 5 && pThird >= 4 && pThird <= 7) ||
        (bp === 6 && (pThird === 6 || pThird === 7))
      ){
        b.push(drawCard());
      }
    }
  }

  pp = point(p);
  bp = point(b);

  return pp > bp ? "player" : bp > pp ? "banker" : "tie";
}


function autoStep(){
  if(!autoBetState.running) return;

  // åˆ°åˆ‡ç‰Œå¡ â†’ æ¢é´ & æ¸…ç©ºè·¯
  
  

  // ===== 1ï¸âƒ£ å†³å®šæ˜¯å¦ä¸‹æ³¨ =====
  const betSide = decideAutoBet(); // "banker" | "player" | null
  autoBetState.lastBet = betSide;

  // ===== 2ï¸âƒ£ å‘ä¸€å±€ç‰Œ =====
  const res = dealOnceSimWithShoe();

  // ===== 3ï¸âƒ£ ç”»è·¯ï¼ˆéå¸¸é‡è¦ï¼‰=====
  drawBead(res);
  drawBigRoad(res);

  // ===== 4ï¸âƒ£ ç»“ç®—ï¼ˆå¦‚æœæœ‰ä¸‹æ³¨ï¼‰=====
  if(betSide){
    autoBetState.totalBet++;

    if(res === betSide){
      autoBetState.win++;
      autoBetState.curWinStreak++;
      autoBetState.curLoseStreak = 0;
      autoBetState.maxWinStreak = Math.max(
        autoBetState.maxWinStreak,
        autoBetState.curWinStreak
      );
    }
    else if(res === "tie"){
      autoBetState.tie++;
      autoBetState.curWinStreak = 0;
      autoBetState.curLoseStreak = 0;
    }
    else{
      autoBetState.lose++;
      autoBetState.curLoseStreak++;
      autoBetState.curWinStreak = 0;
      autoBetState.maxLoseStreak = Math.max(
        autoBetState.maxLoseStreak,
        autoBetState.curLoseStreak
      );
    }
  }

  // ===== 5ï¸âƒ£ ç»§ç»­ =====
  setTimeout(autoStep, 20); // å›æµ‹é€Ÿåº¦
}

function startAutoBetSimulation(){
  autoBetState.running = true;

  autoBetState.totalBet = 0;
  autoBetState.win = 0;
  autoBetState.lose = 0;
  autoBetState.tie = 0;
  autoBetState.curWinStreak = 0;
  autoBetState.curLoseStreak = 0;
  autoBetState.maxWinStreak = 0;
  autoBetState.maxLoseStreak = 0;
  autoBetState.lastBet = null;

  resetRoads();
  createShoe();

  autoStep();
}

function printAutoBetResult(){
  const effective = autoBetState.win + autoBetState.lose;
  const rate = effective === 0
    ? 0
    : ((autoBetState.win / effective) * 100).toFixed(2);

  console.log("====== é—®è·¯è‡ªåŠ¨ä¸‹æ³¨å›æµ‹ ======");
  console.log("æ€»ä¸‹æ³¨å±€æ•°:", autoBetState.totalBet);
  console.log("èµ¢:", autoBetState.win);
  console.log("è¾“:", autoBetState.lose);
  console.log("å’Œ:", autoBetState.tie);
  console.log("èƒœç‡:", rate + "%");
  console.log("æœ€å¤§è¿èƒœ:", autoBetState.maxWinStreak);
  console.log("æœ€å¤§è¿è¾“:", autoBetState.maxLoseStreak);
}


function stopAutoBetSimulation(){
  autoBetState.running = false;
  printAutoBetResult();
}


function stopAutoSimulation(){
  simRunning = false;
}

function resetRoads(){
  beadRoad.innerHTML = "";

  bigMap = {};
  bigCol = 0;
  bigRow = 0;
  lastResult = null;
  bigRoad.innerHTML = "";

  bigEyeRoad = createRoad();
  smallRoadR = createRoad();
  cockroachRoadR = createRoad();

  bigEye.innerHTML = "";
  smallRoad.innerHTML = "";
  cockroachRoad.innerHTML = "";

  renderDerivedRoads();
}

function saveLiveSnapshot(){
  liveHistory.push({
    bigMap: JSON.parse(JSON.stringify(bigMap)),
    bigCol,
    bigRow,
    lastResult,

    bigEyeRoad: JSON.parse(JSON.stringify(bigEyeRoad)),
    smallRoadR: JSON.parse(JSON.stringify(smallRoadR)),
    cockroachRoadR: JSON.parse(JSON.stringify(cockroachRoadR)),

    beadHTML: beadRoad.innerHTML,

    liveScore: JSON.parse(JSON.stringify(liveScore))
  });
}

function restoreLiveSnapshot(){
  if(liveHistory.length === 0){
    alert("å·²ç»æ˜¯æœ€æ—©ä¸€å±€ï¼Œæ— æ³•å›é€€");
    return;
  }

  const s = liveHistory.pop();

  bigMap = s.bigMap;
  bigCol = s.bigCol;
  bigRow = s.bigRow;
  lastResult = s.lastResult;

  bigEyeRoad = s.bigEyeRoad;
  smallRoadR = s.smallRoadR;
  cockroachRoadR = s.cockroachRoadR;

  beadRoad.innerHTML = s.beadHTML;
  liveScore = s.liveScore;

  // ğŸ” é‡æ–°æ¸²æŸ“
  renderBigRoad();
  renderDerivedRoads();
  renderAskRoad();
  renderLiveAsk();
  syncLiveRoadContainers();

  showLiveAdvice(decideLiveBet());
}



function simulateBigStep(state, res){
  let { map, col, row, last } = JSON.parse(JSON.stringify(state));

  if(last === null){
    col = 0;
    row = 0;
  }
  else if(res === last){
    if(
      row + 1 < MAX_ROW &&
      !map[col]?.[row + 1]
    ){
      row++;
    }else{
      col++;
    }
  }
  else{
    col++;
    row = 0;
  }

  map[col] ??= {};
  map[col][row] = { res, tie: 0 };

  return { map, col, row, last: res };
}

function askRoad(nextRes){
  if(nextRes !== "banker" && nextRes !== "player") return null;

  // æ¨¡æ‹Ÿä¸‹ä¸€æ­¥å¤§è·¯ä½ç½®
  const sim = simulateBigStep({
    map: bigMap,
    col: bigCol,
    row: bigRow,
    last: lastResult
  }, nextRes);

  const c = sim.col;
  const r = sim.row;

  return {
    bigEye: calcBigEyeColor(c, r),
    small:  calcSmallRoadColor(c, r),
    cock:   calcCockroachColor(c, r)
  };
}

function renderAskRoad() {
  const b = askRoad("banker");
  const p = askRoad("player");

  // é‡ç½®æ‰€æœ‰å•è·¯æ ¼å­
  const resetCell = (el) => {
    el.className = "askCell";
    el.innerHTML = "";  // å‹™å¿…æ¸…ç©ºæ–‡å­—
  };

  [askBankerEye, askBankerSmall, askBankerCock,
   askPlayerEye, askPlayerSmall, askPlayerCock].forEach(resetCell);

  // èŠå®¶é æ¸¬ - å°æ‡‰ä¸‰ç¨®è·¯åœ–æ¨™
  if (b) {
    if (b.bigEye) {
      askBankerEye.className += " hollow " + b.bigEye;  // ç©ºå¿ƒåœ“ + é¡è‰²
    }
    if (b.small) {
  setAskSmall(askBankerSmall, b.small);
}

    if (b.cock) {
  askBankerCock.className += " cock " + b.cock;
}

  }

  // é–’å®¶é æ¸¬ - åŒä¸Š
  if (p) {
    if (p.bigEye) {
      askPlayerEye.className += " hollow " + p.bigEye;
    }
    if (p.small) {
  setAskSmall(askPlayerSmall, p.small);
}

    if (p.cock) {
  askPlayerCock.className += " cock " + p.cock;
}

  }

  // å¯é¸ï¼šé™¤éŒ¯ç”¨ï¼Œç¢ºèªæœ‰æ²’æœ‰è¨ˆç®—å‡ºä¾†
  // console.log("å•è·¯æ›´æ–° - èŠ:", b, "  é–’:", p);
}

function renderDerivedRoads() {
  renderRoad(bigEyeRoad, bigEye, false, true);     // å¤§çœ¼ â†’ hollow + red/blue
  renderRoad(smallRoadR, smallRoad, false, false); // å°è·¯ â†’ å¯¦å¿ƒ red/blue
  renderRoad(cockroachRoadR, cockroachRoad, true, false); // æ›±ç”´ â†’ æ–œæ  + å¯¦å¿ƒ red/blue
}

/* ===== ç ç›˜è·¯ï¼ˆæ¯å±€ä¸€ä¸ªï¼‰ ===== */
function drawBead(res){
  const d = document.createElement("div");
  d.className = "cell " + res;
  d.innerText = res[0].toUpperCase();
  beadRoad.appendChild(d);
}

// åˆ¤æ–­æŸåˆ—é«˜åº¦ï¼ˆæœ‰å¤šå°‘æ ¼ï¼‰
function colHeight(c){
  return bigMap[c] ? Object.keys(bigMap[c]).length : 0;
}

// åˆ¤æ–­æŸæ ¼æ˜¯å¦å­˜åœ¨
function hasBig(c, r){
  return !!bigMap[c]?.[r];
}

function calcBigEyeColor(c, r){
  // æ–°åˆ—
  if(r === 0){
    if(c < 2) return null;
    return colHeight(c-1) === colHeight(c-2) ? "red" : "blue";
  }
  // åŒåˆ—å‘ä¸‹
  else{
    if(c < 1) return null;
    return hasBig(c-1, r) === hasBig(c-1, r-1)
      ? "red"
      : "blue";
  }
}


function calcSmallRoadColor(c, r) {
  // æ”¾å¯¬ï¼šå¾ç¬¬ 2 åˆ—é–‹å§‹å°±èƒ½è¨ˆç®—ï¼ˆåŸæœ¬å¤ªåš´æ ¼ï¼‰
  if (c < 2) return null;

  // æ–°åˆ—åˆ¤æ–·
  if (r === 0) {
    // è‡³å°‘è¦æœ‰å‰ 3 åˆ—æ¯”è¼ƒï¼Œä½†é˜²è² æ•¸ç´¢å¼•
    if (c < 3) return null;
    const prev1 = colHeight(c - 1);
    const prev3 = colHeight(Math.max(0, c - 3));
    return prev1 === prev3 ? "red" : "blue";
  }
  // åŒåˆ—å‘ä¸‹
  else {
    // æ¯”è¼ƒå·¦ 2 åˆ—çš„è©²è¡Œèˆ‡ä¸Šä¸€è¡Œæ˜¯å¦å­˜åœ¨
    return hasBig(c - 2, r) === hasBig(c - 2, r - 1) ? "red" : "blue";
  }
}

function calcCockroachColor(c, r){
  // æ–°åˆ—ï¼ˆè§„åˆ™ï¼šC-1 vs C-4 åˆ—é«˜åº¦ï¼‰
  if(r === 0){
    if(c < 4) return null;
    return colHeight(c-1) === colHeight(c-4) ? "red" : "blue";
  }
  // åŒåˆ—å‘ä¸‹ï¼ˆè§„åˆ™ï¼šå›ºå®šçœ‹å·¦ä¸‰åˆ—ï¼‰
  else{
    if(c < 3) return null;
    return hasBig(c-3, r) === hasBig(c-3, r-1)
      ? "red"
      : "blue";
  }
}


let bankerAsk = askRoad("banker");
let playerAsk = askRoad("player");

/* ====== å›æµ‹ ====== */

let s6FollowState = {
  running: false,
  waitingForBet: false,   // æ˜¯å¦ç­‰å¾…ä¸‹ä¸€å±€ä¸‹æ³¨
  totalBet: 0,
  win: 0,
  lose: 0,
  tie: 0,

   currentWinStreak: 0,
  currentLoseStreak: 0,
  maxWinStreak: 0,
  maxLoseStreak: 0
};

function dealOncePure(deck){
  let p=[deck.pop(),deck.pop()];
  let b=[deck.pop(),deck.pop()];

  let pp = point(p);
  let bp = point(b);
  let pThird = null;

  if(pp <= 5){
    pThird = deck.pop();
    p.push(pThird);
  }

  if(pThird === null){
    if(bp <= 5) b.push(deck.pop());
  }else{
    if(
      bp <= 2 ||
      (bp === 3 && pThird !== 8) ||
      (bp === 4 && pThird >= 2 && pThird <= 7) ||
      (bp === 5 && pThird >= 4 && pThird <= 7) ||
      (bp === 6 && (pThird === 6 || pThird === 7))
    ) b.push(deck.pop());
  }

  pp = point(p);
  bp = point(b);

  return {
    res: pp > bp ? "player" : bp > pp ? "banker" : "tie",
    bankerPoint: bp
  };
}

function runSuper6FollowSimulation(rounds = 100000){
  // åˆå§‹åŒ–
  s6FollowState.running = true;
  s6FollowState.waitingForBet = false;
  s6FollowState.totalBet = 0;
  s6FollowState.win = 0;
  s6FollowState.lose = 0;
  s6FollowState.tie = 0;

  let deck = [];

  for(let i=0; i<rounds; i++){
    if(deck.length < 6){
      deck = [];
      let base=[1,2,3,4,5,6,7,8,9,0,0,0,0];
      for(let d=0; d<8; d++) base.forEach(c=>deck.push(c));
      deck.sort(()=>Math.random()-0.5);
    }

    let result = dealOncePure(deck);

    // ===== å¦‚æœè¿™æ˜¯ä¸‹æ³¨å±€ =====
    // ===== å¦‚æœè¿™æ˜¯ä¸‹æ³¨å±€ =====
if(s6FollowState.waitingForBet){
  s6FollowState.totalBet++;

  if(result.res === "player"){
    s6FollowState.win++;

    // âœ… è¿èƒœ / è¿è¾“ç»Ÿè®¡
    s6FollowState.currentWinStreak++;
    s6FollowState.currentLoseStreak = 0;

    s6FollowState.maxWinStreak = Math.max(
      s6FollowState.maxWinStreak,
      s6FollowState.currentWinStreak
    );

  }
  else if(result.res === "banker"){
    s6FollowState.lose++;

    // âœ… è¿èƒœ / è¿è¾“ç»Ÿè®¡
    s6FollowState.currentLoseStreak++;
    s6FollowState.currentWinStreak = 0;

    s6FollowState.maxLoseStreak = Math.max(
      s6FollowState.maxLoseStreak,
      s6FollowState.currentLoseStreak
    );

  }
  else{ // tie
    s6FollowState.tie++;

    // å’Œå±€ï¼šæ–­è¿
    s6FollowState.currentWinStreak = 0;
    s6FollowState.currentLoseStreak = 0;
  }

  s6FollowState.waitingForBet = false;
}


    // ===== æ˜¯å¦è§¦å‘è¶…çº§6 =====
    if(result.res === "banker" && result.bankerPoint === 6){
      s6FollowState.waitingForBet = true;
    }
  }

  printSuper6FollowResult();
}

function printSuper6FollowResult(){
  let effectiveTotal = s6FollowState.win + s6FollowState.lose;
let rate = effectiveTotal === 0
  ? 0
  : ((s6FollowState.win / effectiveTotal) * 100).toFixed(2);




  console.log("====== è¶…çº§6 â†’ æŠ¼é—² å›æµ‹ç»“æœ ======");
console.log("æ€»ä¸‹æ³¨å±€æ•°:", s6FollowState.totalBet);
console.log("èµ¢:", s6FollowState.win);
console.log("è¾“:", s6FollowState.lose);
console.log("å’Œ:", s6FollowState.tie);
console.log("èƒœç‡:", rate + "%");
console.log("æœ€é«˜è¿èƒœ:", s6FollowState.maxWinStreak);
console.log("æœ€å¤šè¿è¾“:", s6FollowState.maxLoseStreak);


}

function drawCard(){
  if(dealtCount >= cutPosition){
    alert("åˆ°åˆ‡ç‰Œå¡ï¼Œæ¢é´ï¼");
    resetRoads();
    createShoe();
  }

  dealtCount++;
  return shoe.pop();
}



function decideAutoBet(){
  // ç”¨â€œå°è·¯é—®è·¯â€ä½œä¸ºä¿¡å·ï¼ˆä½ ä¹Ÿå¯ä»¥æ¢ bigEye / cockï¼‰
  const ask = askRoad("banker"); // å…ˆå‡è®¾åº„

  if(!ask || !ask.small) return null;

  // å°è·¯çº¢ â†’ é¡º
  if(ask.small === "red") return "banker";

  // å°è·¯è“ â†’ å
  if(ask.small === "blue") return "player";

  return null;
}

/*å›æµ‹æ–¹æ³•*/

function createMartingaleSizer(){
  const seq = [100, 300, 600, 1200];
  let idx = 0;

  return {
    next(){
      return seq[idx];
    },
    win(){
      idx = 0;
    },
    lose(){
      if(idx < seq.length - 1) idx++;
    },
    reset(){
      idx = 0;
    }
  };
}

function createFlatSizer(){
  return {
    next(){ return 100; },
    win(){},
    lose(){},
    reset(){}
  };
}

const whenStrategies = {
  smallFollow(){
    const ask = askRoad("banker");
    if(!ask || !ask.small) return null;
    return ask.small === "red" ? "banker" : "player";
  },

  bigEyeFollow(){
    const ask = askRoad("banker");
    if(!ask || !ask.bigEye) return null;
    return ask.bigEye === "red" ? "banker" : "player";
  },

  reverse(){
    const ask = askRoad("banker");
    if(!ask || !ask.small) return null;
    return ask.small === "red" ? "player" : "banker";
  },

  // âœ… æ–°å¢ï¼šåº„â‰¤6èµ¢ â†’ åæ‰“é—²
  bankerLowReverse(){
    if(!lastResult || lastBankerPoint == null) return null;

    // åº„èµ¢ ä¸” åº„ç‚¹æ•° â‰¤ 6 â†’ ä¸‹é—²
    if(lastResult === "banker" && lastBankerPoint <= 6){
      return "player";
    }

    return null;
  }
  ,
zeroPointFollowPlayer(){
  // æ²¡æœ‰ä¸Šä¸€å±€ï¼Œä¸ä¸‹æ³¨
  if(!lastResult) return null;

  // å’Œå±€ä¸è§¦å‘
  if(lastResult === "tie") return null;

  // ä¸Šä¸€å±€åº„æˆ–é—² ä»»æ„ä¸€æ–¹æ˜¯ 0 ç‚¹
  if(lastBankerPoint === 0 || lastPlayerPoint === 0){
    return "player";   // ğŸ‘‰ ä¸‹ä¸€æŠŠä¸‹ã€é—²ã€‘
  }

  return null;
}


};
function setAskSmall(el, color) {
  el.className = "askCell small"; // é‡ç½®ç±»å‹
  if(color === "red") el.classList.add("red");
  else if(color === "blue") el.classList.add("blue");
}

function startBacktest(){
  const whenKey = document.getElementById("btWhen").value;
  const sizeKey = document.getElementById("btSizer").value;
  const rounds  = Number(document.getElementById("btRounds").value);

  const when = whenStrategies[whenKey];
  const sizer = sizeKey === "martingale"
    ? createMartingaleSizer()
    : createFlatSizer();

  // ===== å›æµ‹çŠ¶æ€ =====
  let bank = 10000;
  let betCount = 0;
  let win = 0;
  let lose = 0;
  let tie = 0;

  resetRoads();
  createDeck();   // ä½ å·²æœ‰çš„
  sizer.reset();

  for(let i=0;i<rounds;i++){
    // 1ï¸âƒ£ å†³å®šæ˜¯å¦ä¸‹æ³¨
    const side = when();
    let betAmt = 0;

    if(side){
      betAmt = sizer.next();
      betCount++;
    }

    // 2ï¸âƒ£ å‘ä¸€å±€ï¼ˆç”¨ä½ è‡ªå·±çš„ï¼‰
    const res = dealOnceSimWithDeck();

    // 3ï¸âƒ£ ç”»è·¯ï¼ˆéå¸¸å…³é”®ï¼Œç»™ä¸‹ä¸€å±€ç”¨ï¼‰
    drawBigRoad(res);

    // 4ï¸âƒ£ ç»“ç®—
    if(side){
      if(res === side){
        bank += betAmt;
        win++;
        sizer.win();
      }
      else if(res === "tie"){
        tie++;
        sizer.reset(); // ä½ ä¹Ÿå¯ä»¥é€‰æ‹©ä¸ reset
      }
      else{
        bank -= betAmt;
        lose++;
        sizer.lose();
      }
    }
  }

  // ===== è¾“å‡ºç»“æœ =====
  console.log("====== å›æµ‹ç»“æœ ======");
  console.log("æ€»å±€æ•°:", rounds);
  console.log("ä¸‹æ³¨å±€æ•°:", betCount);
  console.log("èµ¢:", win);
  console.log("è¾“:", lose);
  console.log("å’Œ:", tie);
  console.log("èƒœç‡:", (win/(win+lose)*100).toFixed(2)+"%");
  console.log("æœ€ç»ˆèµ„é‡‘:", bank);
}

function decideBetByBankerPoint(lastResult, lastBankerPoint) {
  // åº„èµ¢ + åº„ç‚¹æ•° â‰¤ 6 â†’ ä¸‹ä¸€å±€ä¸‹é—²
  if (lastResult === "banker" && lastBankerPoint <= 6) {
    return "player";
  }
  return null; // ä¸ä¸‹æ³¨
}
/* ====== åˆ†è·¯è§„å¾‹å›æµ‹æ–¹æ³• ====== */
const scoreState = {
  banker: 0,   // å½“å‰åº„çš„ä¸‹æ³¨ç§¯åˆ† %
  player: 0    // å½“å‰é—²çš„ä¸‹æ³¨ç§¯åˆ† %
};

/* =========================================================
   å››è·¯è§„å¾‹ç§¯åˆ†å›æµ‹ï¼ˆç‹¬ç«‹å›æµ‹æ–¹æ³•ï¼‰
   - å¤§è·¯ / å¤§çœ¼ / å°è·¯ / æ›±ç”´
   - æ¯æ¡è·¯å‘½ä¸­è§„å¾‹ â†’ +25%
   - å•å±€ç´¯è®¡ï¼Œå±€åæ¸…é›¶
   - â‰¥75% æ‰ä¸‹æ³¨
   ========================================================= */

function decideSideByDerivedRoadForBT(targetColor, roadKey){
  // roadKey: "bigEye" | "small" | "cock"

  const askB = askRoad("banker");
  const askP = askRoad("player");

  if(!askB || !askP) return null;

  if(askB[roadKey] === targetColor) return "banker";
  if(askP[roadKey] === targetColor) return "player";

  return null;
}
/*
//é”™è¯¯ç‰ˆ
function startPatternScoreBacktest(){

  const rounds = Number(document.getElementById("btRounds").value) || 10000;

  // ===== å›æµ‹èµ„é‡‘ & ç»Ÿè®¡ =====
  let bank = 10000;
  let betCount = 0;
  let win = 0;
  let lose = 0;
  let tie = 0;

  // ===== æ¯ä¸€å±€ç”¨çš„ç§¯åˆ† =====
  let score = {
    banker: 0,
    player: 0
  };

  // ===== é‡ç½®è·¯ç›˜ =====
  resetRoads();
  createDeck();

  // ========= å·¥å…·å‡½æ•° ========= 

  // ä» road.map ä¸­å–æœ€è¿‘ N ä¸ªç»“æœï¼ˆbanker / playerï¼‰å›çœ‹å‰næŠŠ
  function getLastResultsFromRoad(roadMap, n = 6){
    let arr = [];
    Object.keys(roadMap)
      .map(Number)
      .sort((a,b)=>a-b)
      .forEach(c=>{
        Object.keys(roadMap[c])
          .map(Number)
          .sort((a,b)=>a-b)
          .forEach(r=>{
            if(roadMap[c][r].res){
              arr.push(roadMap[c][r].res);
            }
          });
      });
    return arr.slice(-n);
  }

  // åˆ¤æ–­æ˜¯å¦å­˜åœ¨â€œè§„å¾‹â€ï¼Œå¹¶ç»™å‡ºé¢„æµ‹æ–¹å‘
  function detectPattern(seq){
    if(seq.length < 6) return null;

    // 1ï¸âƒ£ å…¨åŒ
    if(seq.every(v=>v===seq[0])){
      return seq[0];
    }

    // 2ï¸âƒ£ åº„é—²äº¤æ›¿
    let alt = true;
    for(let i=2;i<seq.length;i++){
      if(seq[i] !== seq[i-2]){
        alt = false;
        break;
      }
    }
    if(alt){
      return seq[seq.length-2]; // é¢„æµ‹ç»§ç»­äº¤æ›¿
    }

    // 3ï¸âƒ£ æˆå¯¹ï¼ˆåº„åº„é—²é—²ï¼‰
    let pair = true;
    for(let i=0;i<seq.length;i+=2){
      if(seq[i] !== seq[i+1]){
        pair = false;
        break;
      }
    }
    if(pair){
      return seq[seq.length-1];
    }

    // 4ï¸âƒ£ æœ€è¿‘ 6 æ‰‹åŒå‘
    let last6 = seq.slice(-6);
    if(last6.every(v=>v===last6[0])){
      return last6[0];
    }

    return null;
  }

  // ç»™ç§¯åˆ†
  function addScore(side){
    if(!side) return;
    score[side] += 25;
  }

  // åˆ¤æ–­æ˜¯å¦è§¦å‘ä¸‹æ³¨
  function shouldBet(){
    if(score.banker >=100) return "banker";
    if(score.player >= 100) return "player";
    return null;
  }

  // æ¸…é›¶ç§¯åˆ†ï¼ˆä½ è¦æ±‚çš„å…³é”®è§„åˆ™ï¼‰
  function resetScore(){
    score.banker = 0;
    score.player = 0;
  }

   //========= å›æµ‹ä¸»å¾ªç¯ ========= 
  for(let i=0;i<rounds;i++){

    resetScore();

    // ===== ä»å››æ¡è·¯åˆ†åˆ«å–æœ€è¿‘ 10 æ‰‹ =====
    const bigSeq   = getLastResultsFromRoad(bigMap);
    const eyeSeq   = bigEyeRoad.map ? [] : []; // å…¼å®¹
    const smallSeq = smallRoadR.map ? [] : [];
    const cockSeq  = cockroachRoadR.map ? [] : [];

    // å¤§è·¯
    addScore(detectPattern(bigSeq));

    // å¤§çœ¼
    if(bigEyeRoad.last){
      addScore(bigEyeRoad.last === "red" ? "banker" : "player");
    }

    // å°è·¯
    if(smallRoadR.last){
      addScore(smallRoadR.last === "red" ? "banker" : "player");
    }

    // æ›±ç”´
    if(cockroachRoadR.last){
      addScore(cockroachRoadR.last === "red" ? "banker" : "player");
    }

    // ===== åˆ¤æ–­æ˜¯å¦ä¸‹æ³¨ =====
    const betSide = shouldBet();
    let betAmt = 0;

    if(betSide){
      betAmt = (10000) * (score[betSide] / 100);
      betCount++;
    }

    // ===== å‘ç‰Œ =====
    const res = dealOnceSimWithDeck();

    // ===== ç”»è·¯ï¼ˆç»™ä¸‹ä¸€å±€ç”¨ï¼‰=====
    drawBigRoad(res);

    // ===== ç»“ç®— =====
    if(betSide){
      if(res === betSide){
        bank += betAmt;
        win++;
      }
      else if(res === "tie"){
        tie++;
      }
      else{
        bank -= betAmt;
        lose++;
      }
    }
  }

  // ===== è¾“å‡ºç»“æœ =====
  const effective = win + lose;
  const rate = effective === 0 ? 0 : ((win / effective) * 100).toFixed(2);

  console.log("====== å››è·¯è§„å¾‹ç§¯åˆ†å›æµ‹ ======");
  console.log("æ€»å±€æ•°:", rounds);
  console.log("ä¸‹æ³¨å±€æ•°:", betCount);
  console.log("èµ¢:", win);
  console.log("è¾“:", lose);
  console.log("å’Œ:", tie);
  console.log("èƒœç‡:", rate + "%");
  console.log("æœ€ç»ˆèµ„é‡‘:", bank);
}
*/


//æ­£ç¡®ç‰ˆ
function startPatternScoreBacktest(){

  const rounds = Number(document.getElementById("btRounds").value) || 10000;

  // ===== å›æµ‹èµ„é‡‘ & ç»Ÿè®¡ =====
  let bank = 10000;
  let betCount = 0;
  let win = 0;
  let lose = 0;
  let tie = 0;

  // ===== æ¯ä¸€å±€ç”¨çš„ç§¯åˆ† =====
  let score = { banker: 0, player: 0 };

  // ===== é‡ç½®è·¯ç›˜ =====
  resetRoads();
  createDeck();

  // ========= å·¥å…·å‡½æ•° ========= 

  function getLastResultsFromRoad(roadMap, n = 6){
    let arr = [];
    Object.keys(roadMap)
      .map(Number)
      .sort((a,b)=>a-b)
      .forEach(c=>{
        Object.keys(roadMap[c])
          .map(Number)
          .sort((a,b)=>a-b)
          .forEach(r=>{
            if(roadMap[c][r].res){
              arr.push(roadMap[c][r].res);
            }
          });
      });
    return arr.slice(-n);
  }

  function detectPattern(seq){
    if(seq.length < 6) return null;

    if(seq.every(v=>v===seq[0])) return seq[0];

    let alt = true;
    for(let i=2;i<seq.length;i++){
      if(seq[i] !== seq[i-2]){ alt = false; break; }
    }
    if(alt) return seq[seq.length-2];

    let pair = true;
    for(let i=0;i<seq.length;i+=2){
      if(seq[i] !== seq[i+1]){ pair = false; break; }
    }
    if(pair) return seq[seq.length-1];

    let last6 = seq.slice(-6);
    if(last6.every(v=>v===last6[0])) return last6[0];

    return null;
  }

  function addScore(side){
    if(side) score[side] += 25;
  }
// ===== ä¸‹æ³¨ç§¯åˆ† ===== 
  function shouldBet(){
    if(score.banker >= 100) return "banker";
    if(score.player >= 100) return "player";
    return null;
  }

  function resetScore(){
    score.banker = 0;
    score.player = 0;
  }

  // ========= å›æµ‹ä¸»å¾ªç¯ ========= 
  for(let i=0;i<rounds;i++){

    resetScore();

    // ===== â‘  å¤§è·¯ï¼ˆç›´æ¥ç»™æ–¹å‘ï¼‰===== 
    const bigSeq = getLastResultsFromRoad(bigMap);
    const bigSide = detectPattern(bigSeq);
    addScore(bigSide);

    // ===== â‘¡ å¤§çœ¼ï¼ˆç»“åˆé—®è·¯ï¼‰===== 
    if(bigEyeRoad.last){
      const side = decideSideByDerivedRoadForBT(
        bigEyeRoad.last,
        "bigEye"
      );
      addScore(side);
    }

    //===== â‘¢ å°è·¯ï¼ˆç»“åˆé—®è·¯ï¼‰===== 
    if(smallRoadR.last){
      const side = decideSideByDerivedRoadForBT(
        smallRoadR.last,
        "small"
      );
      addScore(side);
    }

    // ===== â‘£ æ›±ç”´ï¼ˆç»“åˆé—®è·¯ï¼‰===== 
    if(cockroachRoadR.last){
      const side = decideSideByDerivedRoadForBT(
        cockroachRoadR.last,
        "cock"
      );
      addScore(side);
    }

    // ===== åˆ¤æ–­æ˜¯å¦ä¸‹æ³¨ ===== 
    const betSide = shouldBet();
    let betAmt = 0;
// ===== ä¸‹æ³¨é‡‘é¢ ===== 
    if(betSide){
      betAmt = 1000 * (score[betSide] / 100);
      betCount++;
    }

    //===== å‘ç‰Œ ===== 
    const res = dealOnceSimWithDeck();

    // ===== ç”»è·¯ï¼ˆç»™ä¸‹ä¸€å±€ç”¨ï¼‰===== 
    drawBigRoad(res);

    // ===== ç»“ç®— ===== 
    if(betSide){
      if(res === betSide){
        bank += betAmt;
        win++;
      }
      else if(res === "tie"){
        tie++;
      }
      else{
        bank -= betAmt;
        lose++;
      }
    }
  }

  // ===== è¾“å‡ºç»“æœ ===== 
  const effective = win + lose;
  const rate = effective === 0 ? 0 : ((win / effective) * 100).toFixed(2);

  console.log("====== å››è·¯è§„å¾‹ç§¯åˆ†å›æµ‹ï¼ˆé—®è·¯ç‰ˆï¼‰ ======");
  console.log("æ€»å±€æ•°:", rounds);
  console.log("ä¸‹æ³¨å±€æ•°:", betCount);
  console.log("èµ¢:", win);
  console.log("è¾“:", lose);
  console.log("å’Œ:", tie);
  console.log("èƒœç‡:", rate + "%");
  console.log("æœ€ç»ˆèµ„é‡‘:", bank);
}
//çœ‹å‰å‡ ä¸ªè·¯
function detectPattern(seq){
    if(seq.length < 6) return null;

    // 1ï¸âƒ£ å…¨åŒ
    if(seq.every(v=>v===seq[0])){
      return seq[0];
    }

    // 2ï¸âƒ£ åº„é—²äº¤æ›¿
    let alt = true;
    for(let i=2;i<seq.length;i++){
      if(seq[i] !== seq[i-2]){
        alt = false;
        break;
      }
    }
    if(alt){
      return seq[seq.length-2]; // é¢„æµ‹ç»§ç»­äº¤æ›¿
    }

    // 3ï¸âƒ£ æˆå¯¹ï¼ˆåº„åº„é—²é—²ï¼‰
    let pair = true;
    for(let i=0;i<seq.length;i+=2){
      if(seq[i] !== seq[i+1]){
        pair = false;
        break;
      }
    }
    if(pair){
      return seq[seq.length-1];
    }

    // 4ï¸âƒ£ æœ€è¿‘ 6 æ‰‹åŒå‘
    let last6 = seq.slice(-6);
    if(last6.every(v=>v===last6[0])){
      return last6[0];
    }

    return null;
  }

function decideLiveBet(){

  // ===== åªåœ¨ â‰¥100% æ—¶æ‰ç»™ä¸‹æ³¨å»ºè®® =====
  if(liveScore.banker >= 100) return "banker";
  if(liveScore.player >= 100) return "player";

  // â— æœªè¾¾ 100%ï¼Œæ˜ç¡®ï¼šä¸ä¸‹æ³¨ã€ä¸æç¤º
  return null;
}




let mode = "sim"; // sim | live

function enterLiveMode() {
  mode = "live";
  document.getElementById("livePanel").style.display = "flex";
  
  // æ¸…ç©ºæ‰€æœ‰è·¯åœ–ï¼ˆé¿å…èˆŠè³‡æ–™å¹²æ“¾ï¼‰
  resetRoads();  // ä½ å·²ç¶“æœ‰é€™å€‹å‡½æ•¸äº†
  
  // é¡¯ç¤ºæç¤º
  document.getElementById("liveAdvice").innerText = "è«‹è¼¸å…¥ä¸Šä¸€å±€çµæœé–‹å§‹è¨˜éŒ„è·¯ç›¤";
  
  // å¯é¸ï¼šå¦‚æœæƒ³å¸¶å…¥ä¹‹å‰çš„è·¯ç›¤ï¼Œå¯ä»¥é€™è£¡å‘¼å« render ä¸€æ¬¡
  // ä½†å¤§å¤šæ•¸äººé€²å…¥å¯¦ç›¤æ¨¡å¼éƒ½å¸Œæœ›å¾é ­é–‹å§‹ï¼Œæ‰€ä»¥ç›´æ¥æ¸…ç©ºå³å¯
}


function showLiveAdvice(side){
  const el = document.getElementById("liveAdvice");

  // ===== æœªè¾¾ 100%ï¼šç³»ç»Ÿä¸åšä¸‹æ³¨æŒ‡ç¤º =====
  if(!side){
    el.innerText = "â¸ ä¿¡å·æœªè¾¾ 100%ï¼Œè‡ªè¡Œåˆ¤æ–­";
    el.style.color = "#aaa";
    return;
  }

  // ===== è¾¾åˆ° 100%ï¼šæ˜ç¡®ä¸‹æ³¨æ–¹å‘ =====
  if(side === "banker"){
    el.innerText = "ğŸ”¥ ä¿¡å·è¾¾æˆ Â· ä¸‹åº„";
    el.style.color = "#ff4d4d";
    return;
  }

  if(side === "player"){
    el.innerText = "ğŸ”¥ ä¿¡å·è¾¾æˆ Â· ä¸‹é—²";
    el.style.color = "#1e90ff";
    return;
  }

  // ===== ç†è®ºå…œåº•ï¼ˆæ­£å¸¸ä¸ä¼šèµ°åˆ°ï¼‰=====
  el.innerText = "â¸ æ— æœ‰æ•ˆä¿¡å·";
  el.style.color = "#aaa";
}


function resetLiveMode(){
  resetRoads();
  document.getElementById("liveAdvice").innerText = "ç­‰å¾…è¾“å…¥â€¦";
}



function exitLiveMode(){
  mode = "sim";
  document.getElementById("livePanel").style.display = "none";
}

function syncLiveRoadContainers(){
  document.getElementById("liveBigRoad").innerHTML =
    document.getElementById("bigRoad").innerHTML;

  document.getElementById("liveBigEye").innerHTML =
    document.getElementById("bigEye").innerHTML;

  document.getElementById("liveSmallRoad").innerHTML =
    document.getElementById("smallRoad").innerHTML;

  document.getElementById("liveCockroachRoad").innerHTML =
    document.getElementById("cockroachRoad").innerHTML;
}
// ===== å®ç›˜ Â· å››è·¯ç§¯åˆ†çŠ¶æ€ =====
let liveScore = {
  banker: 0,
  player: 0
};
function resetLiveScore(){
  liveScore.banker = 0;
  liveScore.player = 0;
}

function addLiveScore(side){
  if(!side) return;
  liveScore[side] += 25;
}

/* =========================
   å®ç›˜ Â· å››è·¯ç§¯åˆ†è®¡ç®—ï¼ˆç‹¬ç«‹å‡½æ•°ï¼‰
   ========================= */
   const livePatternStatus = {
  bigRoad: null,        // "banker" | "player" | null
  bigEye: null,
  smallRoad: null,
  cockroach: null
};

/* =========================
   å®ç›˜ Â· å››è·¯ã€é¡ºåŠ¿ã€‘ç§¯åˆ†è®¡ç®—
   ========================= */
   function decideSideByDerivedRoad(targetColor, roadKey){
  // roadKey: "bigEye" | "small" | "cock"
  // targetColor: "red" | "blue"

  const askB = askRoad("banker");
  const askP = askRoad("player");

  if(!askB || !askP) return null;

  // å¦‚æœã€Œä¸‹åº„ã€ä¼šç”»å‡ºç›®æ ‡é¢œè‰²
  if(askB[roadKey] === targetColor) return "banker";

  // å¦‚æœã€Œä¸‹é—²ã€ä¼šç”»å‡ºç›®æ ‡é¢œè‰²
  if(askP[roadKey] === targetColor) return "player";

  return null;
}

function calculateLiveFourRoadScore(){

  // ===== 1ï¸âƒ£ é‡ç½®ç§¯åˆ† =====
  resetLiveScore();

  // ===== 2ï¸âƒ£ æ¸…ç©ºå±•ç¤ºçŠ¶æ€ =====
  livePatternStatus.bigRoad = null;
  livePatternStatus.bigEye = null;
  livePatternStatus.smallRoad = null;
  livePatternStatus.cockroach = null;

  /* =====================================================
     â‘  å¤§è·¯ï¼ˆç›´æ¥ç»™æ–¹å‘ï¼Œä¸èµ°é—®è·¯ï¼‰
     ===================================================== */
  const bigSeq = (() => {
    let arr = [];
    Object.keys(bigMap)
      .map(Number)
      .sort((a,b)=>a-b)
      .forEach(c=>{
        Object.keys(bigMap[c])
          .map(Number)
          .sort((a,b)=>a-b)
          .forEach(r=>{
            const cell = bigMap[c][r];
            if(cell?.res) arr.push(cell.res);
          });
      });
    return arr.slice(-6);
  })();

  const bigSide = detectPattern(bigSeq);
  if(bigSide){
    livePatternStatus.bigRoad = bigSide;
    addLiveScore(bigSide);
  }

  /* =====================================================
     â‘¡ å¤§çœ¼è·¯ï¼ˆç»“åˆé—®è·¯ï¼‰
     ===================================================== */
  if(bigEyeRoad?.last && derivedRoadReady(bigEyeRoad)){

    const side = decideSideByDerivedRoad(
      bigEyeRoad.last,   // æƒ³é¡ºçš„é¢œè‰²
      "bigEye"
    );
    if(side){
      livePatternStatus.bigEye = side;
      addLiveScore(side);
    }
  }

  /* =====================================================
     â‘¢ å°è·¯ï¼ˆç»“åˆé—®è·¯ï¼‰
     ===================================================== */
  if(smallRoadR?.last && derivedRoadReady(smallRoadR)){

    const side = decideSideByDerivedRoad(
      smallRoadR.last,
      "small"
    );
    if(side){
      livePatternStatus.smallRoad = side;
      addLiveScore(side);
    }
  }

  /* =====================================================
     â‘£ æ›±ç”´è·¯ï¼ˆç»“åˆé—®è·¯ï¼‰
     ===================================================== */
  if(cockroachRoadR?.last && derivedRoadReady(cockroachRoadR)){

    const side = decideSideByDerivedRoad(
      cockroachRoadR.last,
      "cock"
    );
    if(side){
      livePatternStatus.cockroach = side;
      addLiveScore(side);
    }
  }

  // ===== 3ï¸âƒ£ åˆ·æ–° UI =====
  renderLivePatternStatus();
}

function renderLivePatternStatus(){

  const map = {
    bigRoad: "p-big",
    bigEye: "p-eye",
    smallRoad: "p-small",
    cockroach: "p-cockroach"
  };

  for(const key in map){
    const el = document.getElementById(map[key]);
    const side = livePatternStatus[key];

    if(!side){
      el.textContent = "0";
      el.style.color = "#aaa";
    }else{
      el.textContent = `+25% ${side === "banker" ? "åº„" : "é—²"}`;
      el.style.color = side === "banker" ? "#ff5b5b" : "#5bc0ff";
    }
  }
}

function calculateLiveAskRoad(){

  // ç»“æœå¯¹è±¡ï¼šåªç”¨äºå±•ç¤º
  const ask = {
    banker: { bigEye: null, small: null, cockroach: null },
    player: { bigEye: null, small: null, cockroach: null }
  };

  // ===== å‡è®¾ä¸‹ä¸€æŠŠæ˜¯ã€åº„ã€‘ =====
  ask.banker.bigEye     = askBigEyeRoad("banker");
  ask.banker.small      = askSmallRoad("banker");
  ask.banker.cockroach  = askCockroachRoad("banker");

  // ===== å‡è®¾ä¸‹ä¸€æŠŠæ˜¯ã€é—²ã€‘ =====
  ask.player.bigEye     = askBigEyeRoad("player");
  ask.player.small      = askSmallRoad("player");
  ask.player.cockroach  = askCockroachRoad("player");

  renderLiveAskRoad(ask);
}

function renderLiveAskRoad(){
  const banker = askRoad("banker");
  const player = askRoad("player");

  // æ¸…ç©º
  Object.values(liveAsk).forEach(el=>{
    el.className = "askCell";
    el.innerHTML = "";
  });

  if(banker){
    if(banker.bigEye)   liveAsk.bEye.className += " hollow " + banker.bigEye;
    if(banker.small)    setAskSmall(liveAsk.bSmall, banker.small);
    if(banker.cock)     liveAsk.bCock.className += " cock " + banker.cock;
  }

  if(player){
    if(player.bigEye)   liveAsk.pEye.className += " hollow " + player.bigEye;
    if(player.small)    setAskSmall(liveAsk.pSmall, player.small);
    if(player.cock)     liveAsk.pCock.className += " cock " + player.cock;
  }
}

function renderLiveAskRoad(banker, player){
  // å…ˆæ¸…ç©º
  [
    askBankerEye, askBankerSmall, askBankerCock,
    askPlayerEye, askPlayerSmall, askPlayerCock
  ].forEach(el=>{
    el.className = "askCell";
    el.innerHTML = "";
  });

  if(banker){
    if(banker.bigEye)
      askBankerEye.className += " hollow " + banker.bigEye;
    if(banker.small)
      setAskSmall(askBankerSmall, banker.small);
    if(banker.cock)
      askBankerCock.className += " cock " + banker.cock;
  }

  if(player){
    if(player.bigEye)
      askPlayerEye.className += " hollow " + player.bigEye;
    if(player.small)
      setAskSmall(askPlayerSmall, player.small);
    if(player.cock)
      askPlayerCock.className += " cock " + player.cock;
  }
}

function calculateLiveAskRoad(){
  const bankerAsk = askRoad("banker");
  const playerAsk = askRoad("player");

  console.log("å®ç›˜é—®è·¯-åº„:", bankerAsk);
  console.log("å®ç›˜é—®è·¯-é—²:", playerAsk);

  renderLiveAskRoad(bankerAsk, playerAsk);
}

function resetLiveAskCell(el) {
  if (!el) return;
  el.className = "askCell";
  el.innerHTML = "";
}

// é‡ç½®å…¨éƒ¨å¯¦ç›¤å•è·¯æ ¼å­
function resetAllLiveAskCells() {
  Object.values(liveAskCells).forEach(resetLiveAskCell);
}

// å¯¦ç›¤å°ˆç”¨æ¸²æŸ“å•è·¯ï¼ˆåªçœ‹ banker / player å…©ç¨®å‡è¨­ï¼‰
function renderLiveAsk() {
  // å…ˆå…¨éƒ¨æ¸…ç©º
  resetAllLiveAskCells();

  // è¨ˆç®—ã€Œå¦‚æœä¸‹ä¸€æŠŠæ˜¯èŠã€çš„å•è·¯
  const askB = askRoad("banker");
  if (askB) {
    if (askB.bigEye) liveAskCells.bEye.className   += " eye hollow " + askB.bigEye;
    if (askB.small)  setAskSmall(liveAskCells.bSmall, askB.small);
    if (askB.cock)   liveAskCells.bCock.className  += " cock " + askB.cock;
  }

  // è¨ˆç®—ã€Œå¦‚æœä¸‹ä¸€æŠŠæ˜¯é–’ã€çš„å•è·¯
  const askP = askRoad("player");
  if (askP) {
    if (askP.bigEye) liveAskCells.pEye.className   += " eye hollow " + askP.bigEye;
    if (askP.small)  setAskSmall(liveAskCells.pSmall, askP.small);
    if (askP.cock)   liveAskCells.pCock.className  += " cock " + askP.cock;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  åœ¨ inputLive è£¡é¢å‘¼å«ï¼ˆå–ä»£åŸæœ¬çš„å•è·¯ç›¸é—œå‘¼å«ï¼‰
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function inputLive(res) {
  if (mode !== "live") return;

  saveLiveSnapshot();  
 resetLiveScore(); 
  // 1. è¨˜éŒ„é€™ä¸€å±€çµæœ â†’ æ›´æ–°æ‰€æœ‰è·¯åœ–
  drawBead(res);
  drawBigRoad(res);           // é€™ä¸€æ­¥æœ€é‡è¦ï¼æ›´æ–°å¤§è·¯ç‹€æ…‹

  // 2. æ›´æ–°å››è·¯ç©åˆ†ï¼ˆä¿ç•™ä½ åŸæœ‰çš„é‚è¼¯ï¼‰
  calculateLiveFourRoadScore();

  // 3. é‡æ–°è¨ˆç®—ä¸¦é¡¯ç¤ºå•è·¯ï¼ˆä¸»ç•«é¢ + å¯¦ç›¤ï¼‰
  renderAskRoad();            // ä¸»ç•«é¢å•è·¯ï¼ˆå¯é¸ä¿ç•™ï¼‰
  renderLiveAsk();            // å¯¦ç›¤å•è·¯ â† é€™æ˜¯é‡é»

  // 4. åŒæ­¥è·¯åœ–åˆ°å¯¦ç›¤é¢æ¿ï¼ˆä¿æŒåŸæ¨£ï¼‰
  syncLiveRoadContainers();

  // 5. çµ¦å»ºè­°
  const side = decideLiveBet();
  showLiveAdvice(side);
}

// é€²å…¥å¯¦ç›¤æ™‚ä¹Ÿè¦æ¸…ç©ºå•è·¯
function enterLiveMode() {
  mode = "live";
  document.getElementById("livePanel").style.display = "flex";
  
  resetRoads();               // æ¸…ç©ºæ‰€æœ‰è·¯
  resetAllLiveAskCells();     // æ¸…ç©ºå¯¦ç›¤å•è·¯é¡¯ç¤º
  resetLiveScore();
  
  document.getElementById("liveAdvice").innerText = "è«‹è¼¸å…¥ä¸Šä¸€å±€çµæœé–‹å§‹è¨˜éŒ„";
}

function derivedRoadReady(road, min = 10){
  if(!road) return false;

  // ä½ è¿™ä¸ªé¡¹ç›®ç”¨çš„æ˜¯ road.map å¯¹è±¡
  const cols = Object.keys(road.map || {});
  let count = 0;

  cols.forEach(c=>{
    count += Object.keys(road.map[c]).length;
  });

  return count >= min;
}

function getDerivedSeq(road){
  if(!road || !road.map) return [];

  const arr = [];
  Object.keys(road.map)
    .map(Number)
    .sort((a,b)=>a-b)
    .forEach(c=>{
      Object.keys(road.map[c])
        .map(Number)
        .sort((a,b)=>a-b)
        .forEach(r=>{
          arr.push(road.map[c][r]);
        });
    });
  return arr;
}

function detectDerivedPattern(seq){
  if(seq.length < 6) return null;

  // å…¨åŒ
  if(seq.every(v => v === seq[0])){
    return seq[0];
  }

  // äº¤æ›¿ï¼ˆçº¢è“çº¢è“ï¼‰
  let alt = true;
  for(let i = 2; i < seq.length; i++){
    if(seq[i] !== seq[i-2]){
      alt = false;
      break;
    }
  }
  if(alt){
    return seq[seq.length - 2]; // ä¸‹ä¸€æ‰‹
  }

  // æˆå¯¹ï¼ˆçº¢çº¢è“è“ï¼‰
  let pair = true;
  for(let i = 0; i < seq.length; i += 2){
    if(seq[i] !== seq[i+1]){
      pair = false;
      break;
    }
  }
  if(pair){
    return seq[seq.length - 1];
  }

  return null;
}


/* ====== åˆå§‹åŒ– ====== */
createShoe();     // âœ… ä¸€å®šè¦å…ˆ
createDeck();     // ï¼ˆæ¨¡æ‹Ÿ / å›æµ‹ç”¨ï¼‰
balanceSpan();
updateBetStats();

/*æŸ¥çœ‹åˆ‡ç‰Œä½ç½®è¯­å¥***é‡è¦ï¼ä¸èƒ½åˆ ï¼
console.log("Shoe è¿›åº¦:", getShoeProgress());*/

</script>

</body>
</html>
